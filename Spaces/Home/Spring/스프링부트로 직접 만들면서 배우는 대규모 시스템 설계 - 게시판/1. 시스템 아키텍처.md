## 프로젝트 요구사항
### 게시판 기능 명세
이 게시판 시스템은 다음과 같은 기능들을 포함한다
- 게시글 CRUD: 단일 게시글의 조회, 생성, 수정, 삭제 기능과 목록 조회 기능
- 댓글 기능: 계층형 댓글 구조를 지원하며, 최대 2-depth 혹은 무한 depth까지 확장 가능
- 좋아요 기능: 게시글에 대한 좋아요 수 집계
- 조회수 기능: 사용자별 10분 단위로 조회수를 집계하여 중복 카운트를 방지
- 인기글 선정: 하루 단위로 댓글 수, 좋아요 수, 조회수 등을 기반으로 상위 10개 인기글을 선정하며, 매일 오전 1시에 업데이트됨
- 최근 인기글 히스토리 조회: 최근 N일 간의 인기글 데이터를 조회 가능
- 성능 최적화 전략: 단건 및 목록 조회 최적화, 캐시 전략 등을 적용해 게시글 조회 성능 개선

## 배울 수 있는 것
•대규모 시스템에 적용할 수 있는 방법론 및 개발 전략
•서버 애플리케이션을 개발하며 적절한 도구를 활용하는 것이 주 목적
•Relational Database의 이해 및 활용
•MySQL 테이블 및 인덱스 설계, 쿼리 최적화, 데이터베이스 이론
•In-memory Database의 이해 및 활용
•Redis에서 지원하는 다양한 연산과 자료구조
•Message Broker의 이해 및 활용
•Kafka의 동작 원리
•분산 이벤트 스트리밍 및 비동기 처리 애플리케이션 구축
•어떻게 고민하면서 어떤 코드를 만드는가?


## 모놀리식 아키텍처 vs MSA
### 모놀리식 아키텍처
Monolithic Architecture로 구성된 애플리케이션을 서버 한 대에 배포하였다.
단일 코드베이스로 관리하기 때문에, 각 애플리케이션에는 모든 기능이 포함되어있다.
![[IMG-20250703023037022.png|500]]
모놀리식 구조는 단일 코드베이스로 관리되며, 하나의 서버에 배포되는 구조이다. 
소규모 시스템에서는 빠르게 개발하고 배포하기에 적합하지만, 다음과 같은 한계가 있다

- 특정 기능만 확장하기 어렵고,
- 하나의 수정이 전체 시스템에 영향을 미칠 수 있으며,
- 점차 커지는 복잡도로 인해 유지보수 난이도가 상승한다

### 마이크로서비스 아키텍처
![[IMG-20250703022925412.png|500]]이 문제를 해결하기 위해 MSA(Microservice Architecture)를 도입할 수 있다.
각 기능별로 서비스를 분리하면 다음과 같은 이점이 있다

- 기능별로 독립된 배포 및 확장 가능
- 서비스 단위의 책임과 코드 복잡도 감소

하지만 고려해야 할 점도 많다

- 서비스 간 통신 비용 증가 (ex. REST, gRPC)
- 분산 트랜잭션 관리
- 로그 집계, 모니터링 시스템 구축
- 서비스 분리 기준 수립
- 테스트 전략, 데이터 일관성 보장

### 정리
![[IMG-20250703022502570.png|500]]

### 게시판 프로젝트에서의 MSA 구성
각 요구사항 별로 총 6개의 마이크로서비스를 만들어본다. 
• 게시글 서비스 
• 댓글 서비스 
• 좋아요 서비스 
• 조회수 서비스 
• 인기글 서비스 
• 게시글 조회 서비스


## 분산 관계형 DB 설계와 샤딩 전략
### 데이터베이스 확장의 필요성
시스템의 트래픽과 데이터량이 증가할수록 단일 DB로 감당하기 어려워진다. 이때 Scale-Out 전략을 통해 수평적으로 DB를 확장할 수 있다.
그렇다면, 데이터는 각 DB에 어떻게 분산될 수 있을까?

### 샤딩
![[IMG-20250703023343957.png|500]]
샤딩은 데이터를 여러 DB에 분산 저장하는 기술이며, 각 단위 DB를 '샤드(Shard)'라고 한다.

####  수직 샤딩(Vertical Sharding)
![[IMG-20250703023402099.png|500]]
데이터를 컬럼 기준으로 분할하는 방식이다. 
예를 들어, 게시글의 `title`, `content`는 하나의 샤드에, ``created_at`, `board_id`는 다른 샤드에 저장할 수 있다.

- 장점: 컬럼 수가 적어져 조회 성능 개선, 저장 공간 최적화
- 단점: 조인 시 성능 저하, 수평 확장에는 적합하지 않음

#### 수평 샤딩(Horizontal Sharding)
![[IMG-20250703023505127.png|500]]
데이터를 행 단위로 분할하는 방식이다. 
예를 들어, `article_id` 1~5000은 샤드 A, 5001~10000은 샤드 B에 저장한다. 

- 장점: 데이터가 분산 저장되므로 성능 및 공간 이점
- 단점: 범위 조회 시 다수 샤드 접근 필요, 조인 또는 트랜잭션 관리 복잡성 증가


#### Range-based Sharding(범위 기반 샤딩)
![[IMG-20250703023616824.png|500]]
데이터를 특정 값(Shard Key)을 기준으로 범위를 나눠 저장한다. 
`article_id` 1~5000, 5001~10000
- 장점: 범위 조회에 유리
  (article_id=100부터 30개 조회한다면 좌측 샤드에서 모든 데이터를 찾을 수 있음)
- 단점: 쏠림 현상 발생 가능, 균등 분산 어려움
  데이터가 6,000개만 있다면, 우측 샤드에는 1,000개만 저장

균등한 분산을 위한 Shard Key와 해시 함수가 필요하다. 
균등하게 분산되지 않으면, 데이터 쏠림 현상 발생 가능 
만약, board_id가 Shard Key 라면? 인기 많은 게시판에 데이터가 몰릴 수 있음

범위 데이터 조회에 불리할 수 있다. 
shard_key = article_id 인 상황에 게시판의 게시글 목록을 조회하려면?
-> article_id 기준으로 데이터가 분산되었기 때문에 모든 샤드에 요청 해야할 수도 있다. 
시스템 특성에 따라서 적절한 Shard Key와 해시 함수를 선정해야한다.

#### 디렉토리 기반 샤딩 (Directory-based Sharding)
![[IMG-20250703023647242.png|500]]
별도의 매핑 테이블을 통해 어떤 데이터가 어떤 샤드에 있는지를 관리한다.
좌측 샤드 `article_id` = 1, 4 
우측 샤드 `article_id` = 2, 3

- 장점: 유연한 분산 및 이동 가능
- 단점: 매핑 디렉토리의 관리 비용 존재

외에도 데이터의 특성 또는 시스템 요구사항에 따라 다양한 샤딩 기법이 있고, 자신의 시스템에 알맞은 샤딩 기법을 직접 만들 수도 있다. 
샤딩의 개념과 각 기법의 특성을 이해하고, 시스템 특성에 따라 적절한 기법을 선택하는 것이 중요하다

### 물리적 샤드와 논리적 샤드
대규모 트래픽과 데이터 저장 요구가 증가하면, 하나의 데이터베이스 인스턴스로는 감당이 어려워진다. 이를 해결하기 위해 **샤딩**을 적용하게 되는데, 이때 반드시 고민해야 할 부분이 **물리적 샤드(Physical Shard)**와 **논리적 샤드(Logical Shard)** 개념이다.

#### 해시 기반 샤딩과 물리적 샤드 증가 문제
![[IMG-20250703023725137.png|500]]
위 그림에서는 DB가 2대로 물리적 분리되었다. 2개의 물리적 샤드(Physical Shard)를 가지는 것이다.

물리적 샤드가 2개인 위 상황에서 Hash-based Sharding을 적용해보자. 
2개의 샤드에 균등한 분산을 위해 아래와 같은 해시 함수를 적용한다. 
`hash_function = article_id -> article_id % 2` 
8개의 데이터는 2개의 샤드에 4개씩 균등하게 분산되었다

![[IMG-20250703023825053.png|500]]
이 경우 각 샤드는 4개의 데이터를 가지게 되며, 균등하게 분산된 상태다.

그런데 데이터 양이 급격히 증가해 샤드를 4개로 늘려야 하는 상황이 왔다면, 
기존 해시 함수 `article_id % 2`는 무용지물이 되고, 
다음과 같은 새로운 해시 함수를 적용해야 한다 `article_id % 4`

하지만 이 변경으로 인해 `article_id = 3, 4, 7, 8` 등 일부 데이터는 기존 샤드에서 다른 샤드로 이동하게 된다. 
이처럼 **샤드 개수 변경 시 기존 데이터의 대규모 재배치가 발생**하며, 동시에 클라이언트도 **새로운 샤드 구성 정보를 알아야 하므로 코드 수정이 불가피**하다.

이 문제는 단순히 DB 확장만의 이슈가 아닌, 애플리케이션 아키텍처 전반의 리팩토링으로 이어질 수 있다.

#### 논리적 샤드(Logical Shard)의 개념
이 문제를 해결하기 위해 도입되는 것이 **논리적 샤드**이다.

![[IMG-20250703023908115.png|500]]
논리적 샤드는 **실제 존재하지 않는 개념적 샤드**로, 클라이언트는 물리적 샤드의 존재를 인지하지 않고, **정해진 개수의 논리적 샤드로만 데이터를 분산**시킨다. 
예를 들어 물리적으로는 2개의 샤드만 존재하지만, 클라이언트는 4개의 논리 샤드가 있다고 가정하고 다음과 같이 데이터를 분산한다

`hash_function = article_id -> article_id % 4`

그렇다면 이 논리 샤드가 어떤 물리 샤드에 대응되는지를 누가 알 수 있을까?
바로 **라우터(Router)**가 필요하다.

#### 라우터의 역할
라우터는 논리 샤드와 물리 샤드 간의 매핑을 담당한다. 예를 들어 다음과 같이 매핑될 수 있다

![[IMG-20250703023939826.png|500]]
여기서는 이러한 Router가 DB 시스템 내부에 포함된다고 가정한다. 

이 구조에서 클라이언트는 단지 논리 샤드 ID로 요청을 보내고, 내부적으로 라우터가 이를 해당 물리 샤드로 라우팅한다.

예를 들어, article_id = 5 데이터를 요청하려면? 
Client 입장에서는 4개의 논리적 샤드가 있으므로 5 % 4 = 1번 샤드로 Router에 요청한다. 
Router는 1번 논리적 샤드에 대한 요청을 받아서, 좌측 물리적 샤드로 라우팅한다.
```java
// 클라이언트 → 라우터
logicalShardId = 5 % 4 = 1 → Router → 물리 샤드 A로 전달
```

이제 물리 샤드를 2개에서 4개로 확장한다고 해보자. 라우터의 매핑만 다음처럼 변경하면 된다

![[IMG-20250703024040750.png|500]]
논리적으로 4개의 샤드로 분산되어 있지만, 물리적 샤드가 늘어남에 따라서 데이터를 물리적으로 다시 재배치할 수 있다.

이 때 클라이언트는 여전히 `articleId % 4`만 계산할 뿐이고, 실제 데이터가 어느 DB에 있는지 모른다. 중요한 점은 **클라이언트의 코드를 수정하지 않아도 된다는 것**이다.

### 정리
|항목|기존 해시 기반 샤딩|논리적 샤드 + 라우터 구조|
|---|---|---|
|샤드 개수 확장 시|해시 함수 변경 필요 → 데이터 재배치 + 클라이언트 수정 필요|라우터 수정만으로 확장 가능|
|클라이언트 복잡도|샤드 정보를 직접 알아야 함|논리적 샤드 ID만 알고 있음|
|샤드 간 데이터 재배치 비용|전체 재분산 발생 가능|라우터 레벨에서 최소화 가능|

## 요약
- 이 강의에서 설명한 분산 설계 개념은 관계형 DB에 한정되지 않는다
- Redis, Kafka와 같은 NoSQL 시스템에도 동일하게 응용된다
- 외에도, 분산 시스템에서 추가적인/확장된 개념이나 고려해야할 부분은 더욱 많다.

| 개념           | 설명                      |
| ------------ | ----------------------- |
| Quorum       | 다수결 원리에 의한 합의 도출        |
| Split Brain  | 클러스터 네트워크 분리 시 이중 운영 문제 |
| Multi-Leader | 다중 마스터 구성 시 동기화 문제      |
| Consensus    | 분산 시스템 간 상태 합의          |
| Clock Skew   | 시계 차이에 의한 일관성 문제        |
- 실무에서는 모든 구성을 직접 하지 않더라도, 개념 이해를 통해 문제 상황에 빠르게 대처할 수 있다
- 클라우드 서비스나 오픈소스를 활용하여 설계 및 운영을 효율화할 수 있다