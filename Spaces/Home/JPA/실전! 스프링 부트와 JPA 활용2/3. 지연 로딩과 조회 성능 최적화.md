### 간단한 주문 조회 V1: 엔티티를 직접 노출

<aside> 💡 **실무에서 정말 중요한 내용**

</aside>

```java
/**
 * XToOne관계
 * Order
 * Order -> Member @ManyToOne
 * Order -> Delivery @OneToOne
 */
@RestController
@RequiredArgsConstructor
public class OrderSimpleApiController {

    private final OrderRepository orderRepository;

    @GetMapping("/api/v1/simple-orders")
    public List<Order> ordersV1() {

				//select o from Order o join o.member m
        List<Order> all = orderRepository.findAllByString(new OrderSearch());
        return all;
    }
}
```

- order → member와 order → address 는 지연 로딩으로 설정되어있다.
- 따라서 실제 엔티티 대신에 프록시 존재
- jackson 라이브러리는 기본적으로 이 프록시 객체를 json으로 어떻게 생성해야 하는지 모름

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2921fa62-9546-4333-8427-c02a06dcd14c/Untitled.png)

→ InvalidDefinitionException 발생 (ByteBuddy~~)

- Hibernate5Module을 스프링 빈으로 등록하면 해결됨

```java
@Bean
Hibernate5Module hibernate5Module() {
   Hibernate5Module hibernate5Module = new Hibernate5Module();
   return hibernate5Module;
}
```

- 기본적으로 초기화 된 프록시 객체만 노출, 초기화 되지 않은 프록시 객체는 노출 안함
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4583a2e3-068d-4930-bb8c-ab1cfdbea3a3/Untitled.png)
    
- 다음과 같이 설정하면 강제로 지연 로딩 가능
    

```java
@Bean
Hibernate5Module hibernate5Module() {
   Hibernate5Module hibernate5Module = new Hibernate5Module();
	 //강제 지연 로딩 설정
   hibernate5Module.configure(Hibernate5Module.Feature.FORCE_LAZY_LOADING, true);
   return hibernate5Module;
}
```

- 이 옵션을 키면 order -> member , member -> orders 양방향 연관관계를 계속 로딩하게 된다. 따라서 @JsonIgnore 옵션을 한곳에 주어야 한다.
    
- member, orderItems, delivery 정보가 같이 나옴
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5f654954-d24a-44d4-bdb1-3e2549915da5/Untitled.png)
    
- 원하는 엔티티 정보만 가져오기
    

```java
@RestController
@RequiredArgsConstructor
public class OrderSimpleApiController {

    private final OrderRepository orderRepository;

    @GetMapping("/api/v1/simple-orders")
    public List<Order> ordersV1() {
        List<Order> all = orderRepository.findAllByString(new OrderSearch());
        for (Order order : all) {
            order.getMember().getName();    //Lazy 강제 초기화
            order.getDelivery().getAddress();    //Lazy 강제 초 기화
        }

        return all;
    }
}
```

- order.getMember() 까지만 하면 프록시 객체인데 필드를 가져와야 함으로 Lazy가 강제 초기화가 되서 Member테이블에 쿼리를 날려 가져오게 된다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b1b25f9-732d-41f3-94bc-62a0351c9a4d/Untitled.png)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90092ff1-9e94-4e6d-930d-254e9bd64ba9/Untitled.png)
    

### **간단한 주문 조회 V2: 엔티티를 DTO로 변환**

쿼리가 총 1 + N + N번 실행된다.(v1과 쿼리수 결과는 같다.)

- order 조회 1번(order 조회 결과 수가 N이 된다.
- order -> member 지연 로딩 조회 N 번
- order -> delivery 지연 로딩 조회 N 번
- 예) order의 결과가 4개면 1 + 4 + 4번 실행된다.(최악의 경우)
    - 지연로딩은 영속성 컨텍스트에서 조회하므로, 이미 조회된 경우 쿼리를 생략한다.

```java
/**
 * V2. 엔티티를 조회해서 DTO로 변환(fetch join 사용X)
 * - 단점: 지연로딩으로 쿼리 N번 호출
 */
@GetMapping("/api/v2/simple-orders")
public List<SimpleOrderDto> ordersV2() {
    List<Order> orders = orderRepository.findAllByString(new OrderSearch());

    List<SimpleOrderDto> result = orders.stream()
            .map(o -> new SimpleOrderDto(o))
            .collect(Collectors.toList());

    return result;
}

@Data
static class SimpleOrderDto {
    private Long orderId;
    private String name;
    private LocalDateTime orderDate;
    private OrderStatus orderStatus;
    private Address address;

    public SimpleOrderDto(Order order) {
        orderId = order.getId();
        name = order.getMember().getName();
        orderDate = order.getOrderDate();
        orderStatus = order.getStatus();
        address = order.getDelivery().getAddress();
    }
}
```

```
1.
select
        order0_.order_id as order_id1_6_,
        order0_.delivery_id as delivery4_6_,
        order0_.member_id as member_i5_6_,
        order0_.order_date as order_da2_6_,
        order0_.status as status3_6_ 
    from
        orders order0_ 
    inner join
        member member1_ 
            on order0_.member_id=member1_.member_id limit ?
2.
    select
        member0_.member_id as member_i1_4_0_,
        member0_.city as city2_4_0_,
        member0_.street as street3_4_0_,
        member0_.zipcode as zipcode4_4_0_,
        member0_.name as name5_4_0_ 
    from
        member member0_ 
    where
        member0_.member_id=?
3.
        delivery0_.delivery_id as delivery1_2_0_,
        delivery0_.city as city2_2_0_,
        delivery0_.street as street3_2_0_,
        delivery0_.zipcode as zipcode4_2_0_,
        delivery0_.status as status5_2_0_ 
    from
        delivery delivery0_ 
    where
        delivery0_.delivery_id=?
4.
    select
        member0_.member_id as member_i1_4_0_,
        member0_.city as city2_4_0_,
        member0_.street as street3_4_0_,
        member0_.zipcode as zipcode4_4_0_,
        member0_.name as name5_4_0_ 
    from
        member member0_ 
    where
        member0_.member_id=?
5. 
    select
        delivery0_.delivery_id as delivery1_2_0_,
        delivery0_.city as city2_2_0_,
        delivery0_.street as street3_2_0_,
        delivery0_.zipcode as zipcode4_2_0_,
        delivery0_.status as status5_2_0_ 
    from
        delivery delivery0_ 
    where
        delivery0_.delivery_id=?
```

쿼리가 총 5번 나감(Order가 2건이기 때문에 SimpleOrderDto()가 2바퀴 돔)

- 1 select order → `List<Order> orders = orderRepository.findAllByString(new OrderSearch());`
- 2,4 select member → `SimpleOrderDto() -``name = order.getMember().getName();`
- 3,5 select delivery → `SimpleOrderDto() -``address =order.getDelivery().getAddress();`

### **간단한 주문 조회 V3: 엔티티를 DTO로 변환 - 페치 조인 최적화**

엔티티를 페치 조인을 사용해서 쿼리 1번에 조회한다.

```java
@GetMapping("/api/v3/simple-orders")
    public List<SimpleOrderDto> ordersV3() {
        List<Order> orders = orderRepository.findAllWithMemberDelivery();
        List<SimpleOrderDto> result = orders.stream()
                .map(order -> new SimpleOrderDto(order))
                .collect(Collectors.toList());

        return result;
    }
```

```java
public List<Order> findAllWithMemberDelivery() {
    return em.createQuery(
            "select o from Order o" +
                    " join fetch o.member m" +
                    " join fetch o.delivery d", Order.class
    ).getResultList();
}
```

```
select
        order0_.order_id as order_id1_6_0_,
        member1_.member_id as member_i1_4_1_,
        delivery2_.delivery_id as delivery1_2_2_,
        order0_.delivery_id as delivery4_6_0_,
        order0_.member_id as member_i5_6_0_,
        order0_.order_date as order_da2_6_0_,
        order0_.status as status3_6_0_,
        member1_.city as city2_4_1_,
        member1_.street as street3_4_1_,
        member1_.zipcode as zipcode4_4_1_,
        member1_.name as name5_4_1_,
        delivery2_.city as city2_2_2_,
        delivery2_.street as street3_2_2_,
        delivery2_.zipcode as zipcode4_2_2_,
        delivery2_.status as status5_2_2_ 
    from
        orders order0_ 
    inner join
        member member1_ 
            on order0_.member_id=member1_.member_id 
    inner join
        delivery delivery2_ 
            on order0_.delivery_id=delivery2_.delivery_id
```

### 간단한 주문 조회 V4: JPA에서 DTO로 바로 조회