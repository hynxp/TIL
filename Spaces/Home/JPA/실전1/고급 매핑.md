### 상속관계 매핑

- 관계형 데이터베이스는 상속 관계가 아니다.
    
- **슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사**
    
- 상속관계 매핑: 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9e4f3eb6-dd06-4461-a4b9-570d4c4ec65d/Untitled.png)
    
- **슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법**
    
    - 각각 테이블로 변환 -> 조인 전략
    - 통합 테이블로 변환 -> 단일 테이블 전략
    - 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략

> **JOINED: 조인 전략**

ex) @Inheritance(strategy=InheritanceType.**JOINED**)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6004bd26-3fa5-4edc-ac32-841c56546fb0/Untitled.png)

- 장점
    - 테이블 정규화
    - 외래 키 참조 무결성 제약조건 활용가능
    - 저장공간 효율화
- 단점
    - 조회시 조인을 많이 사용, 성능 저하
    - 조회 쿼리가 복잡함
    - 데이터 저장시 INSERT SQL 2번 호출

> **SINGLE_TABLE: 단일 테이블 전략**

ex) @Inheritance(strategy=InheritanceType.**SINGLE_TABLE**)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/52a11c2a-83ee-4057-8bcc-0ac9e3001428/Untitled.png)

- 장점
    - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
    - 조회 쿼리가 단순함
- 단점
    - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다.

> **TABLE_PER_CLASS: 구현 클래스마다 테이블 전략**

ex) @Inheritance(strategy=InheritanceType.**TABLE_PER_CLASS**)

<aside> 💡 이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천X

</aside>

- 장점
    - 서브 타입을 명확하게 구분해서 처리할 때 효과적
    - not null 제약조건 사용 가능
- 단점
    - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요)
    - 자식 테이블을 통합해서 쿼리하기 어려움

> **@DiscriminatorColumn**

- 하위 엔티티를 구분하는 컬럼이 생성된다. (default = DTYPE)

ex) DTYPE = ‘A’

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn    //하위 클래스를 구분하는 용도의 컬럼이 생김 default = DTYPE
public abstract class Item {
}
```

> **@DiscriminatorValue(“XXX”)**

- 컬럼에 들어갈 값을 지정할 수 있다.(default = 클래스명)

```java
@Entity
@DiscriminatorValue("M")
public class Movie extends Item{
}
```

### @MappedSuperclass