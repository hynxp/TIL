### 연관관계 매핑시 고려사항 3가지

1. **다중성**
    
    - 다대일: @ManyToOne
    - 일대다: @OneToMany
    - 일대일: @OneToOne
    - 다대다: @ManyToMany
2. **단방향, 양방향**
    
    - 테이블
        - 외래 키 하나로 양쪽 조인 가능
        - 사실 방향이라는 개념이 없음
    - 객체
        - 참조용 필드가 있는 쪽으로만 참조 가능
        - 한쪽만 참조하면 단방향
        - 양쪽이 서로 참조하면 양방향
3. **연관관계의 주인**
    
    - 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
    - 객체 양방향 관계는 A→B, B→A 처럼 참조가 2군데
    - 외래 키를 갖고있는 쪽이 관리, 연관관계의 주인
    - 주인의 반대편: 외래 키에 영향을 주지 않음, 단순 조회만 가능

### 다대일 [N:1]

> **다대일 단방향**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a658b8f5-2b98-4cd2-864b-db2d63426296/Untitled.png)

- 가장 많이 사용하는 연관관계
- **다대일**의 반대는 **일대다**

> **다대일 양방향**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/29e5f5e2-f2a8-4b7a-9b34-ad6db477ec3a/Untitled.png)

- 외래 키가 있는 쪽이 연관관계의 주인
- 양쪽을 서로 참조하도록 개발

### 일대다 [1:N]

<aside> 💡 추천하지않음

</aside>

> **일대다 단방향**

![Team에선 Member를 알고 싶은데, Member에선 Team을 알고 싶지 않을 때](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c1dcd80c-9b8d-40ae-819b-ea86492f1cff/Untitled.png)

Team에선 Member를 알고 싶은데, Member에선 Team을 알고 싶지 않을 때

- 일대다 단방향은 일대다(1:N)에서 **일(1)**이 연관관계의 주인
    
- 테이블 일대다 관계는 항상 **다(N)**쪽에 외래 키가 있음
    
- 객체와 테이블의 차이 때문에 반대별 테이블의 외래 키를 관리하는 특이한 구조
    
- @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간 테이블이 추가됨)
    
- 연관관계 관리를 위해 추가로 UPDATE SQL 실행
    
    ```jsx
    //회원 저장
    Member member = new Member();
    member.setName("member1");
    em.persist(member);
    
    //팀 저장
    Team team = new Team();
    team.setName("TeamA");
    
    //**
    team.getMembers().add(member);
    
    em.persist(team);
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9e90490a-7d01-4aa5-90dc-a5a431dfc7ce/Untitled.png)
    
    team에 add를 해도 외래키는 Member테이블에 있기 때문에 Member테이블에 굳이 한번 더 update를 쳐줘야 함
    
    = 일대다 단방향 매핑보다는 **다대일 양방향 매핑을 사용**하자
    

> **일대다 양방향**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1f41c125-ed39-470a-b09a-803f16669b78/Untitled.png)

- 이런 매핑은 공식적으로 존재X
    
- @JoinColumn(insertable=false, updatable=false)
    
    읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법.
    
- **다대일 양방향 매핑을 사용**하자
    

### 일대일 [1:1]

- 일대일 관계는 그 반대도 일대일
- 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
    - 주 테이블에 외래 키
    - 대상 테이블에 외래 키
- 외래 키에 데이터베이스 UNIQUE 제약조건 추가된 것

> **주 테이블에 외래키 단방향**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d930776-a308-4744-88ff-72ed0dac2d48/Untitled.png)

- 다대일(@ManyToOne) 단방향 매핑과 유사

```java
@Entity
public class Member {

   @OneToOne
   @JoinColumn(name = "locker_id")
   private Locker locker;
}
```

> **주 테이블에 외래키 양방향**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bcf7e7d2-2d70-444e-a669-3d0a219520cb/Untitled.png)

- 다대일 양방향 매핑처럼 **외래키가 있는 곳이 연관관계의 주인**
- 반대편은 mappedBy 적용

```java
@Entity
public class Locker {

   @OneToOne(mappedBy = "locker")
   private Member member;
}
```

> **대상 테이블에 외래키 단방향**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb91221a-fde7-49a1-a2aa-1706418435ad/Untitled.png)

- 대상 테이블 단방향은 지원하지X

> **대상 테이블에 외래키 양방향**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b2882269-3ab0-4947-9f79-54ac54e664f9/Untitled.png)

- 사실 일대일 주 테이블에 외래키 양방향과 매핑 방법은 같음

> **정리**

- **주 테이블에 외래 키**
    - 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
    - 객체지향 개발자 선호
    - JPA 매핑 편리
    - 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
    - 단점: 값이 없으면 외래 키에 null 허용(라커가 없으면 null이 들어가야 함)
- **대상 테이블에 외래 키**
    - 대상 테이블에 외래 키가 존재
    - 전통적인 데이터베이스 개발자 선호
    - 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지.(멤버가 라커를 여러개 가지도록 비즈니스 룰이 변경될 경우 테이블 구조 유지하면서 유지보수 가능)
    - 단점: 프록시 기능의 한계로 **지연 로딩으로 설정해도 항상 즉시 로딩됨**(프록시는 뒤에서 설명)
        - JPA 입장에서 일대일 관계의 주 테이블에 외래 키를 저장하는 상황에서는, 멤버 객체를 로딩할 때, 멤버 테이블의 FK에 라커 ID가 있는지 없는지만 판단하면 된다. 있으면 프록시 객체를 넣어주고, 없으면 null을 넣으면 된다. 나중에 진짜 라커 필드에 엑세스 할 때, 그때 쿼리가 나간다.
        - 그런데, 대상 테이블에 외래 키를 저장한다면, JPA가 멤버의 라커를 조회하는 상황에서 DB의 멤버 테이블만 조회해서는 모른다. 어차피 라커 테이블을 찾아서 멤버가 있는지 확인 해야(쿼리를 날려 봐야) 알 수 있다. 어차피 쿼리가 나간단 이야기는 프록시를 만들 필요가 없다는 이야기이다. 그래서 지연 로딩으로 설정해도 항상 즉시 로딩 된다.

### 다대다 [N:M]