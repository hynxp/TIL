##  캐시가 없다면
캐시가 없다면 이미지에 대한 리소스를 요청할 때마다 계속 다운로드 받아야 한다.
![[8. HTTP 헤더2 - 캐시와 조건부 요청-20240411170010684.webp]]
- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다.
- 인터넷 네트워크는 매우 느리고 비싸다.
- 브라우저 로딩 속도가 느리다
- 느린 사용자 경험

## 캐시 적용
첫 번째 이미지 요청의 cache-control에 캐시가 유효한 시간을 60초로 설정하고 요청하게 되면
웹 브라우저는 브라우저 캐시의 유효 시간을 검증해 시간이 유효하다면 저장되어있는 이미지를 사용한다.
![[8. HTTP 헤더2 - 캐시와 조건부 요청-20240411170148887.webp]]
- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다. 
- 비싼 네트워크 사용량을 줄일 수 있다. 
- 브라우저 로딩 속도가 매우 빠르다. 
- 빠른 사용자 경험

**캐시 유효 시간이 초과하면?** 
서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다.
이때 다시 1.1메가의 네트워크 다운로드가 발생한다.

## 검증 헤더와 조건부 요청1
위에서 **캐시 유효 시간이 초과**됐을 때를 **해결**할 수 있는 매커니즘이다.

만약 유효 시간이 초과되고 같은 star.jpg를 요청했을 때 만약 서버측의 star.jpg도 변하지 않았다면 저장해 두었던 캐시를 재사용하면 되지 않을까?
이때 **검증 헤더**라는 게 들어간다.

### Last-Modified

![[8. HTTP 헤더2 - 캐시와 조건부 요청-20240411170732581.webp]]
1. 서버측은 응답할 때 **Last-Modified** 즉 이 데이터의 최종 수정일을 같이 보낸다.
2. 브라우저 측은 캐시에 최종 수정일을 같이 저장한다.

### if-modified-since
만약 star.jpg에 대해 2번째 요청이 들어오면
![[8. HTTP 헤더2 - 캐시와 조건부 요청-20240411170926156.webp]]
3.  클라이언트는 내가 캐시에 들고있던 최종 수정일은 이거에요! 라는 **if-modified-since**를 넘긴다.
4. 서버는 본인이 갖고 있던 최종 수정일과 비교한다.
![[8. HTTP 헤더2 - 캐시와 조건부 요청-20240411171126761.webp]]
5. 만약 변한 게 없다면 헤더에 **304 Not Modified**를 보내고 HTTP Body없이 응답한다.

ex) 네이버에서 이미지를 요청했을 때
![[8. HTTP 헤더2 - 캐시와 조건부 요청-20240411171910105.webp|400]]

> [!NOTE] 정리
> - 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면 HTTP Body 없이 헤더에 304 Not Modied + 메타 정보만 응답
> - 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
> - 클라이언트는 캐시에 저장되어 있는 데이터 재활용
> - 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드하기 때문에 매우 실용적인 해결책이다.

## 검증 헤더와 조건부 요청2
### 검증 헤더 - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
ex) [[8. HTTP 헤더2 - 캐시와 조건부 요청#Last-Modified|Last-Modified]] ETag
### 조건부 요청 헤더
ex) [[8. HTTP 헤더2 - 캐시와 조건부 요청#if-modified-since|If-Modified-Since]] 
**만약 If-Modied-Since: 이후에 데이터가 수정되었으면?**
캐시: 2020년 11월 10일 **10:00:00** vs 서버: 2020년 11월 10일 **11:00:00**
-> 200 OK를 헤더에 보내고 HTTP Body를 포함한 모든 데이터 전송한다. 
-> 전송 용량 1.1M (헤더 0.1M, 바디 1.0M)

**만약 If-Modied-Since: 이후에 데이터가 수정되지 않았으면?**
캐시: 2020년 11월 10일 **10:00:00** vs 서버: 2020년 11월 10일 **10:00:00**
-> 304 Not Modified를 헤더에 보내고 HTTP Body를 제외한 헤더 데이터만 전송한다.
-> 전송 용량 0.1M (헤더 0.1M, 바디 0M)

### Last-Modied, If-Modied-Since 단점
- 1초 미만(0.x초) 단위로 캐시 조정이 불가능 
- 날짜 기반의 로직 사용한다.
	데이터를 몇 번 수정했지만 결국 같은 이미지로 복구해놓을 수도 있다. 하지만 날짜가 바뀐다.
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우가 있을 수 있다.
	ex) 스페이스나 주석같은 거 바꿨지만 그냥 캐시를 유지하고 싶은 경우

### ETag(Entity Tag), If-None-Match
Last-Modied, If-Modied-Since 단점에서 서버에서 완전하게 캐시 메커니즘을 컨트롤 할 수 있는 방법이다.
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
	ex) ETag: "v1.0", ETag: "a2jiodwjekjl3"
- 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성)
	ex) ETag: "aaaaa" -> ETag: "bbbbb" 
- **진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기!**

**예시**
![[8. HTTP 헤더2 - 캐시와 조건부 요청-20240411173230456.webp]]
서버는 요청에 ETag를 같이 넘긴다. 브라우저는 이 응답 결과를 캐시에 저장한다.
![[8. HTTP 헤더2 - 캐시와 조건부 요청-20240411173456201.webp]]
두 번째 요청을 했을 때 브라우저는 내 캐시에 이런 ETag가 있다 하고 If-None-Match에 담아 넘긴다.
캐시가 만료돼도 Etag가 같기 때문에 **304 Not Modified를 헤더에 보내고 HTTP Body를 제외한 헤더 데이터만 전송한다.**

> [!NOTE] 정리
> - 진짜 단순하게 **ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기!** 
> - **캐시 제어 로직을 서버에서 완전히 관리** 
> - 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름) 
> ex) 
> 	서버는 배타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지 
> 	애플리케이션 배포 주기에 맞추어 ETag 모두 갱신

## 캐시와 조건부 요청 헤더
### Cache-Control - 캐시 제어 
**Cache-Control: max-age** 
캐시 유효 시간, 초 단위 입력 가능

**Cache-Control: no-cache**
데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 캐시를 써라!

**Cache-Control: no-store** 
데이터에 민감한 정보가 있으므로 저장하면 안돼!
(메모리에서 사용하고 최대한 빨리 삭제하세요.)

### Pragma - 캐시 제어(하위 호환) 
**Pragma: no-cache** 
HTTP 1.0 하위 호환이라 거의 사용하지 않음
### Expires - 캐시 유효 기간(하위 호환)
`expires: Mon, 01 Jan 1990 00:00:00 GMT`

- 캐시 만료일을 **정확한 날짜로 지정** 
- HTTP 1.0 부터 사용 
- 지금은 더 유연한 Cache-Control: max-age 권장 
	- Cache-Control: **max-age와 함께 사용하면 Expires는 무시**된다.

> [!NOTE] 검증 헤더와 조건부 요청 헤더 정리
> **검증 헤더 (Validator)** 
> - Tag: "v1.0", ETag: "asid93jkrh2l"
> - Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT 
>  **조건부 요청 헤더** 
> - If-Match, If-None-Match: ETag 값 사용 
> - If-Modified-Since, If-Unmodified-Since: Last-Modied 값 사용

## 프록시 캐시

### 프록시 캐시란?
한국에 있는 여러 클라이언트에서 미국 서버에 접근을 한다고 치자.
(이때 미국의 원 서버를 **오리진 서버**라고 한다.)
이때 0.5초가 걸린다고 하면 전부 다 0.5초씩 기다려야 한다.

![[8. HTTP 헤더2 - 캐시와 조건부 요청-20240411174535857.webp]]

그래서 **프록시 캐시 서버**라는 것을 도입했다.
한국 어딘가에 프록시 캐시 서버를 넣어놓고 요청이 오면 이 서버를 요청해 오리진 서버에 접근한다.
ex) 유튜브나 넷플릭스 스트리밍...
![[8. HTTP 헤더2 - 캐시와 조건부 요청-20240411174443343.webp]]

### Cache-Control - 캐시 지시어
- **Cache-Control: public** 
	응답이 public 캐시에 저장되어도 됨
- **Cache-Control: private** 
	응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함(기본값) 
- **Cache-Control: s-maxage** 
	프록시 캐시에만 적용되는 max-age 
- **Age: 60** (HTTP 헤더) 
	오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)
