객체 지향 4대 특성을 넘어 자바가 객체 지향을 확장하기 위해 사용하는 키워드와 개념을살펴보자.

## abstract 키워드 - 추상 메서드와 추상 클래스
추상 메서드(Abstract Method)를 간단하게 설명하면 선언부는 있는데 구현부가 없는 메서드를 말 한다. 추상 메서드를 하나라도 갖고 있는 클래스는 반드시 추상 클래스(Abstract Class)로 선언해야 한다.

추상 클래스는 인스턴스, 즉 객체를 만들 수 없는 클래스가 된다.

- 추상 클래스는 인스턴스, 즉 객체를 만들 수 없다. 즉, new를 사용할 수 없다
- 추상 메서드는 하위 클래스에게 메서드의 구현을 강제한다. 오버라이딩 강제
- 추상 메서드를 포함하는 클래스는 반드시추상 클래스여야 한다.


## 생성자
클래스의 인스턴스, 즉 객체를 만들 때마다 new 키워드를 사용한다.

반환값이 없고 클래스명과 같은 이름을 가진 메서드를 객체를 생성하는 메서드라고 해서 객체 생성자 메서드라 한다. 그리고 줄여서 생성자라는 이름으로 더 많이 부른다.

- 개발자가 아무런 생성자도 만들지 않으면 자바는 인자가 없는 기본 생성자를 자동으로 만들어준다.
- 인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성자를 만들어 주지 않는다.


## 클래스 생성 시의 실행 블록, static 블록
클래스 생성자는 존재하지 않는다. 그러나 클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록이 있다. 바로 static 블록이다.

```java
public class 동물 {
static {
System.out.printin（"동물 클래스 레디 온!"）;
}
```

```java
public static void main(String[] args) {
동물 뽀로로 = new 동물()； //동물 클래스 레디 온! 실행
}
```

```java
public static void main(String[] args) {
System.out.println("main 메서드 시작!");
동물 뽀로로 = new 동물()；
동물 피카츄 = new 동물()； // 인스터스가 여러개여도 동물 클래스의 static 블록은 단 한번만 실행된다.
}
```
클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 T 메모리의 스태틱 영역에 로딩되며, 이때 단 한번 해당 클래스의 Static 블록이 실행된다. 여기서 클래스가 제일 처음 사용될 때는 다음 세 가지 경우 중 하나다.

- 클래스의 정적속성을 사용할 때
- 클래스의 정적 메서드를 사용할 때
- 클래스의 인스턴스를 최초로 만들 때


## final 키워드
final은 마지막, 최종이라는 의미를 가진 단어다. final 키워드가 나타날 수 있는 곳은 딱 세 군데다. 사실 객체 지향 언어의 구성 요소는 딱 세 가지 뿐이다. 바로 클래스, 변수, 메서드다.

### final과 클래스
```java
public final class 고양이 { }
```
상속을 허락하지 않겠다는 의미다. 따라서 하위 클래스를 만들 수 없다.

### final과 변수
```java
final static int 정적_상수 = 1 ；
```
변경 불가능한 상수가 된다. 정적 상수는 선언 시에, 또는 정적 생성자에 해당하는 static 블록 내부에서 초기화가 가능하다. 객체 상수 역시 선언 시에, 또는 객체 생성자 또는 인스턴스 블록에서 초기화할 수 있다. 지역 상수 역시 선언 시에, 또는 최초 한 번만 초기화가 가능하다.

### final과 메서드
메서드가 final이라면 최종이니 재정의, 즉 오버라이딩을 금지하게 된다.


## instanceof 연산자
인스턴스는 클래스를 통해 만들어진 객체라고 했다. instanceof 연산자는 만들어진 객체가 특정 클래 스의 인스턴스인지 물어보는 연산자다. instanceof 연산자는 결과로 true 또는 false를 반납한다. 사용법은 아래와 같다.

```java
객체_참조_변수 instanceof 클래스명
동물 동물객체 = new 동물（）；
System.out.printin（동물객체 instanceof 동물）;
```
instanceof 연산자가 강력하기는 하지만 객체 지향 설계 5원칙 가운데 LSP （리스코프 치환 원 칙）를 어기는 코드에서 주로 나타나는 연산자이기에 코드에 instanceof 연산자가 보인다면 냄새 나 는 코드가 아닌지, 즉 리팩터링의 대상이 아닌지 점검해 봐야 한다.

instanceof 연산자는 클래스들의 상속 관계뿐만 아니라 인터페이스의 구현 관계에서도 동일하게 적 용된다.


## package 키워드
package 키워드는 네임스페이스（이름공간）를 만들어주는 역할을 한다.

다른 패키지에 같은 클래스를 만들어도 충돌이 나지 않는다.

![[Pasted image 20250116072955.png|400]]


## interface 키워드와 implements 키워드
인터페이스는 public 추상 메서드와 public 정적 상수만 가질 수 있다고 했다.

```java
interface Speakable {
	double PI = 3.14159；
	final double absoluteZeroPoint = -275.15；
	void sayYes()；
}

class Speaker implements Speakable {
	public void sayYes() {
		System.out.println("I say NO!!!")；
	}
}

public class Driver {
	public static void main(String[] args) {
		System.out.println(Speakable.absoluteZeroPoint)；
		System.out.println(Speakable.PI)；
		Specker reporterl = new SpeckerO；
		reporterl .sayYesO；
	}
}
```
인터페이스는 추상 메서드와 정적 상수만 가질 수 있기에 따로 메서드에 public과 abstract, 속성에 public과 static, final을 붙이지 않아도 자동으로 자바가 알아서 붙여준다.


## this 키워드
this는 객체가 자기 자신을 지칭할 때 쓰는 키워드다. 마치 일상생활에서 “나”라고 하는 대명사와 같은 것이라고 보면 된다.

- 지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 지역 변수가 우선한다.
- 객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this를 접두사로 사용한다.
- 정적 변수와 이름이 같은 지역 변수가 있는 경우 정적 변수를 사용하려면 클래스명을 접두사로 사용한다.


## super 키워드
super는 바로 위 상위 클래스의 인스턴스를 지칭하는 키워드다.

super 키워드로 바로 위의 상위 클래스 인스턴스에는 접근할 수 있지만 super.super 형태로 상위의 상위 클래스의 인스턴스에는 접근이 불가능하다.


## 예비 고수를 위한 한마디
똑같은 객체 멤버 메서드를 힙 영역에 여러 개를 만든다는 것은 심각한 메모리 낭비라고 할 수 있다. 그래서 JVM은 지능적으로 객체 멤버 메서드를 스태틱 영역에 단 하나만 보유한다. 그리고 눈에 보이지는 않지만 메서드를 호출할 때 객체 자신을 나타내는 this 객체 참조 변수를 넘긴다.