## 자바 프로그램의 개발과 구동

| 현실세계                | 가상세계         | 설명                          |
|-------------------------|------------------|-------------------------------|
| 소프트웨어 개발 도구    | JDK - 자바 개발 도구 | JVM용 소프트웨어 개발 도구    |
| 운영체제                | JRE - 자바 실행 환경 | JVM용 OS                     |
| 하드웨어 - 물리적 컴퓨터 | JVM - 자바 가상 기계 | 가상의 컴퓨터                |
**JVM(Java Virtual Machine)의 존재와 역할을 아는 것이 자바 개발 환경을 이해하는 데 필수적**이다. JVM은 이름 그대로 가상기계다. 
현실 세계에서 컴퓨터를 구동하기 위해서는 물리적 컴퓨터인 하드웨어와 운영체제, 그리고 그 위에서 구동될 소프트웨어가 필요하다. 거기에 더해 소프트웨어를 개발할 수 있는 개발 도구가 필요하다. 자바의 가상 세계는 이러한 현실 세계를 그대로 모방하고 있다.

자바 개발 도구인 JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터 인 JVM 상에서 구동된다.

다만 배포되는 JDK, JRE, JVM은 편의를 위해 JDK가JRE를 포함하고 다시 JRE는 JVM을 포함하는 형태로 배포된다.

## 자바의 메모리 영역

![[Pasted image 20250110021505.png]]
코드 실행 영역과 데이터 저장 영역으로 나뉘고, 데이터 저장 영역은 다시 스태틱, 스택, 힙 3가지로 나뉜다.(T처럼 생겨 T메모리라고도 함)

### 다시 보는 main() 메서드: 메서드 스택 프레임
```java
public class Start {
 public static void main(String[] args) {
    System.out.println("Hello OOP!!!")；
 }
}
```

![[Pasted image 20250110021758.png]]

JRE는 먼저 프로그램 안에 main() 메서드가 있는지 확인한다. main() 메서드의 존재가 확인되면 가상의 기계인 JVM에 전원을 넣어 부팅한다. 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행한다. JVM이 맨 먼저 하는 일은 전처리라고 하는 과정이다.

모든 자바 프로그램이 반드시 포함하게 되는 패키지가 있다. 바로 java.lang 패키지다. JVM은 가장 먼저 java,lang 패키지를 T 메모리의 스태틱 영역에 가져다 놓는다. java.lang 패키지가 있기에 System.out.printin() 같은 메서드를 쓸 수 있게 되는 것이다.

![[Pasted image 20250110021813.png]]

main() 메서드가 실행되기 전 JVM에서 수행하는 전처리 작업들

- javaJang 패키자를 T 메모리의 스태틱 영역에 배치한다.
- import된 패키지를 T 메모리의 스태틱 영역에 배치한다.
- 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치한다

main() 메서드가 놀기 위해 스택 프레임 (stackframe)이 스택 영역에 할당된다. 조금 더 정확히 이 야기하자면 여는 중괄호를 만날 때마다 스택 프레임이 하나씩 생긴다. 클래스 정의를 시작하는 여는 중괄호만 빼고 말이다.

![[Pasted image 20250110021828.png]]

메서드의 인자 args를 저장할 변수공간을 스택 프레임의 맨 밑에 확보해야 한다. 즉, 메서드 인자(들)의 변수 공간을 할당하는 것이다. 위의 그림처럼 T 메모리를 구성하고 나서야 main() 메서드 안의 첫 명 령문을 실행하게 된다.

JRE는 눈에 보이지 않게 뒤에서JVM이라고 하는 자바 가상 기계를 부팅하고, JVM은 메모리 구조를 만들고 거기에 java.lang 패키지로딩, 각종클래스로딩, main() 메서드스택 프레임 배치, 변수공간 배치 등등의 일을 처리했다.

닫는 중괄호를 만나면 스택 프레임이 소멸된다.

main() 메서드가 프로그램의 시작점이라고 했는데 끝이기도 하다. main() 메서드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다. 그럼 T 메모리도 이제 그 운명을 다하고 사라지게 되는 것이다.


### 변수와 메모리: 변수! 너 어디 있니?
```java
public class Start2 {
	public static void main(String[] args) {
		 int i;
		 i = 10;

		 double d = 20.0;
		}
 }
```

![[Pasted image 20250110021910.png]]

7번째 줄의 닫는중괄호로 main() 메서드 스택 프레임이 스택 영역에서 사라진다. 즉, 프로그램이 종 료된다


### 블록 구문과 메모리: 블록 스택 프레임
```java
 public class Start3 {
	public static void main(String[] args) {
		 int i = 10;
		 int k = 20;
		
		 if(i = 10) {
			 int m = k + 5；;
			 k = m; //8
		 } else {
			 int p = k + 10;
			 k = p;
		 }
		
		 //k = m + p;
	}
}
```

8번째 줄 실행했을 때 메모리

![[Pasted image 20250110022029.png]]
if문이 끝나면 사라짐
![[Pasted image 20250110022115.png]]


### 지역 변수와 메모리: 스택 프레임에 갇혔어요!
**변수는 스태틱 영역, 스택 영역, 힙 영역 중 어디에 있는 걸까?** 답은 ‘**세 군데에 모두**’다. 그런데 세 군데 각각에 있는 변수는 각기 다른 목적을 가진다. 그리고 각각의 이름도 지역 변수, 클래스 멤버 변수, 객체 멤버 변수로 다르다.

`지역 변수`는 스택 영역에서 일생을 보낸다. 그것도 스택 프레임 안에서 일생을 보내게 된다. 따라서 스택 프레임이 사라지면 함께 사라진다.

`클래스 멤버 변수`는 스태틱 영역에서 일생을 보낸다. 스태틱 영역에 한번 자리 잡으면 JVM이 종료될 때까지 고정된(static) 상태로 그 자리를 지킨다.

`객체 멤버 변수`는 힙에서 일생을 보낸다. 객체 멤버 변수들은 객체와 함께 가비지 컬렉터라고 하는 힙메모리 회수기에 의해 일생을 마치게 된다

> _“외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다.”_
> why? 내부 스택 프레임이 제일 내부의 메서드이므로 먼저 사라지기 때문임


### 메서드 호출과 메모리: 메서드 스택 프레임 2
메서드를 호출하면서 인자로 전달되는 것은 변수 자체가 아니라 변수가 저장한 값만을 복제해서 전달한다. 이런 전달 방식을 값에 의한 전달이라고 해서 Call By Value라고 한다.

#### 각 스택 프레임 안의 지역 변수들끼리는 왜 접근이 불가능할까?
1. 메서드는 서로의 고유 공간이므로 침범하면 문제를 유발할 수 있기 때문이다.
2. 포인터 문제 때문이다. 변수에 접근한다는 것은 변수의 메모리 위치, 즉 포인터(메모리 주소 값)을 알아야 하는데 자바는 포인터를 지원하지 않는다.


### 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!
```java
public class Starts {
	static int share;
	
	public static void main(String[] args) {
		share = 55;
		
		int k = fun(5, 7)；
		
		System.out.printIn(share)；
	}
	
	private static int fun(int m, int p) {
		share = m + p;
		
		return m - p;
	}
}
```
![[Pasted image 20250110022920.png]]

static 키워드가 붙은 전역 변수 share은 해당 클래스가 T 메모리 스태틱 영역에 배치될 때 그 안에 클래스의 멤버로 공간을 만들어 저장된다..

#### 전역 변수는 왜 쓰지 말라고 할까?
프로젝트 규모가 커지면서 여러 메서드에서 전역 변수의 값을 변경하기 시작하면 전역 변수 값을 파악하기 어렵기 때문이다.
다만 읽기 전용으로 값을 공유해서 전역 상수(`private final`)로 쓰는 것은 적극 추천한다.



## 멀티 스레드 / 멀티 프로세스의 이해
멀티 스레드(Multi Thread)의 T 메모리 모델은 스택 영역을 스레드 개수만큼 분할해서 쓰는 것이다.
![[Pasted image 20250110023222.png]]
스태틱, 힙은 스레드가 공유하기 때문이다.

멀티 프로세스(Multi Process)는 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조다.
![[Pasted image 20250110023258.png]]
**멀티 프로세스**는 각 프로세스마다 각자의 T 메모리가 있고 각자 고유의 공간이므로 서로 참조할 수 없다. 그에 반해 **멀티 스레드**는 하나의 T 메모리만 사용하는데 스택 영역만 분할해서 사용하는 구조다.

자바 웹 프로그래밍을 공부해 본 적이 있다면 서블릿은 요청당 프로세스가 아닌 요청당 스레드를 생성한다는 말이 머릿속 어딘가에 콕 박혀 있을 것이다. 이제는 **요청당 스레드(Servlet)가 요청당 프로세스(CGI)보다 왜 더 효율적인지** 이해할수 있을 것이다.

**멀티 스레드에서 전역 변수 사용의 문제점**을 살펴보자. 두 개의 스레드로 구성된 프로그램이 있다고 해보자. 스레드1이 공유 영역 (스태틱과 힙)에 있는 전역 변수 A에 10을 할당했다고 해보자. 그런데 CPU 사용권이 스레드2로 넘어가고 스레드2가 전역 변수 A에 20을 할당하고 다시 CPU 사용권이 스레드1로 넘어가서 A의 값을 출력해 보면 어떻게 될까? 스레드1의 입장에서는 갑자기 20이라는 값이 출력되는 문제가 발생한다.

바로 위의 절에서 전역 변수를 쓰지 말라는 말이 기억날 것이다. 쓰기 가능한 전역 변수를 사용하게 되면 스레드 안전성이 깨진다고 표현한다. 물론 이를 보완하는 방법으로 락(lock)을 거는 방법이 있기 는 하다. 하지만 락을 거는 순간 멀티 스레드의 장점은 버린 것과 같다.


## 정리 - 객체 지향은 절차적/구조적 프로그래밍의 어깨를 딛고
UML 액티비티 다이어그램을 그리는 것도 좋긴 하지만, 필자가 제일 좋아하는 메서드의 로직 설계 방법은 NS 다이어그램이다. NS 다이어그램의 정식 명칭은 나시 슈나이더만 다이어그램 (NassiShneiderman diagram)이다.

**UML 다이어그램**
![[Pasted image 20250110023537.png]]

**NS 다이어그램**
![[Pasted image 20250110023632.png]]

2장에서 T 메모리를 설명하면서 힙 영역은 설명하지 않았다. 힙 영역은 객체가 상주하는 구역이기 때 문이다. 객체를 사용한 적이 없기에 힙 영역에 대한 설명이 아직 등장하지 않은 것이다.