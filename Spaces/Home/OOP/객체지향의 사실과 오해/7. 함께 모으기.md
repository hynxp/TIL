사실 6장까지 읽으면서도 정말 좋은 책이라고 느꼈지만, 마지막 장을 딱 읽고나서야 클라이막스에 다다라 유종의 미를 거둔 느낌이었다.
6장까지 이론적인 이해를 완전히 했다면, 7장에서는 이때까지 이해한 걸 바탕으로 실제 도메인 설계를 탑다운으로 방식으로 설명해 완벽하게 이해시켜준다.
넥스트스텝으로 객체지향 코드에 꽤 익숙해져있었고, 이론도 많이 공부했기 때문에 글이 정말 잘 읽혔고 아 이게 왜 객체지향의 바이블인지 이해할 수 있었다. 정말 좋았던 책 땅땅!

---

객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점에 관해 설명한다. 
파울러는 세 가지 관점을 각각 `개념 관점, 명세 관점, 구현 관점`이라고 부른다.

> 💡 **개념 관점(Conceptual Perspective)**  
> 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.  
> 이 관점은 사용자가 도메인을 바라보는 관점을 반영한다.
> 도메인이란 사용자들이 관심을 갖고 있는 특정 분야나 주제를 말하며, 소프트웨어란 이 도메인에 존재하는 문제를 해결하기 위해 개발된다.
> 따라서 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심이다.

> 💡 **명세 관점(Specification Perspective)**  
> 소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞춘다.  
> 즉, 객체의 인터페이스를 바라보게 된다. 명세 관점에서 프로그래머는 객체가 협력을 위해 ‘무엇’을 할 수 있는가에 초점을 맞춘다.
> 인터페이스와 구현을 분리하는 객체지향 설계에서 가장 기본적인 원칙이라는 점을 기억하자!

> 💡 **구현 관점(Implementation Perspective)**
> 실제 작업을 수행하는 코드와 연관되어있으며, 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 데 초점이 있다. 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성한다.  
> 프로그래머는 책임을 ‘어떻게’ 수행할 것인가에 초점을 맞추며, 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다.

**개념 관점, 명세 관점, 구현 관점**은 **동일한 클래스를 세가지 다른 방향에서 바라보는 것**을 의미한다.

클래스는 세 가지 관점이라는 안경을 통해 설계와 관련된 다양한 측면을 드러낼 수 있다.

- 클래스가 은유하는 개념은 도메인 관점을 반영한다.
- 클래스의 공용 인터페이스는 명세 관점을 반영한다.
- 클래스의 속성과 메서드는 구현 관점을 반영한다.

클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 하며, 동시에 코드 안에서 세 가지 관점을 쉽게 식별할 수 있도록 깔끔하게 분리해야 한다.

협력에 참여하기 위해 객체가 수신해야 하는 메시지를 결정하고 메시지들이 모여 객체의 인스턴스를 구성한다는 점을 기억하자.
따라서 협력 안에서 메시지를 선택하고 메시지를 수신할 객체를 선택하는 것은 객체의 인터페이스, 즉 명세 관점에서 객체를 바라보는 것이다.


## 커피 전문점 도메인
### 커피 전문점이라는 세상
개발에 들어가기 전에 먼저 커피 전문점을 구성하는 요소들에 관해 고민해봐야 한다.

1. `커피` 전문점 안에는 `메뉴판`이 존재한다. 객체지향의 관점에서 메뉴판은 하나의 객체다.
2. `메뉴판`은 네 개의 `메뉴 항목`으로 구성돼 있는데 메뉴 항목들 역시 객체로 볼 수 있다. 따라서 메뉴판은 네 개의 메뉴 항목 객체들을 포함하는 객체라고 볼 수 있다.
3. `손님`은 메뉴판을 보고 `바리스타`에게 원하는 커피를 주문한다. 객체의 관점에서 보면 손님 역시 하나의 객체다.
4. `바리스타`는 주문을 받은 메뉴에 따라 적절한 커피를 제조한다.
5. `바리스타`가 제조하는 `커피` 역시 메뉴판, 메뉴 항목, 바리스타와 구별되는 자신만의 경계를 가지므로 객체로 볼 수 있다.

> **종합해 보면 객체지향의 관점에서 커피 전문점이라는 도메인은 손님 객체, 메뉴 항목 객체, 메뉴판 객체, 바리스타 객체, 커피 객체로 구성된 작은 세상이다.**



![[Pasted image 20250617021041.png|400]]
#### 객체들 간의 관계
어떤 객체가 존재하는지 살펴봤으므로 이제는 객체들 간의 관계를 살펴볼 시간이다.

- 손님은 메뉴판에서 주문할 커피를 선택할 수 있어야 함 
    - 손님과 메뉴판 사이의 관계 필요 
- 손님은 바리스타에게 주문 해야 함 
    - 손님과 바리스타 사이의 관계 필요 
- 바리스타는 자신의 커피와도 관계가 필요함

커피 전문점을 구성하는 범주로서 손님 타입, 메뉴판 타입, 메뉴 항목 타입, 바리스타 타입, 커피 타입이 갖춰진다. 이제 타입 간에 어떤 관계가 존재하는지 살펴보자.

 ![[Pasted image 20250617021339.png|200]]
메뉴판 타입에서 메뉴 항목 타입 쪽으로 향하는 선에 그려진 속이 찬 마름모는 `포함(containment)` 관계 또는 `합성(composition)` 관계를 나타내는 것으로, 메뉴 항목이 메뉴판에 포함된다는 사실을 표현한다.

![[Pasted image 20250617021355.png|200]]
`손님` 타입은 `메뉴판` 타입을 알고 있어야 원하는 커피를 선택할 수 있다. 
메뉴판 타입은 손님의 일부가 아니므로 이 관계는 `합성` 관계가 아니다. 
이 경우 타입들 사이를 단순한 선으로 연결한다. 
이처럼 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있어야 할 경우 이를 `연관(association) 관계`라고 한다.

![[Pasted image 20250617021417.png|200]]
위 그림은 커피 전문점 도메인을 구성하는 타입들의 종류와 관계를 표현한 것이다.  
이처럼 소프트웨어가 대상으로 하는 영역인 도메인을 단순화해서 표현한 모델을 `도메인 모델`이라고 한다.


## 설계하고 구현하기
### 1. 커피를 주문하기 위한 협력 찾기

![[Pasted image 20250617021457.png]]
`협력을 설계할 때는 메시지가 객체를 선택해야 한다.` 이 메시지를 토대로 협력을 설계해 보자.  

메시지 위에 붙은 화살표는 메시지에 담아 전달될 부가적인 정보인 인자를 의미한다.  
이 경우 ‘아메리카노를 주문하라’ 메시지는 나중에 ‘커피를 주문하라(아메리카노)’와 같이 인자를 포함하는 형식으로 구현될 것이다.  

`적절한 타입을 발견했다면 책임을 수행할 객체를 그 타입의 인스턴스로 만들어라.`  
‘커피를 주문하라’라는 메시지를 수신할 객체는 무엇인가? 당연히 손님일 것이다.  
따라서 메시지를 처리할 객체는 손님 타입의 인스턴스다.

![[Pasted image 20250617021606.png]]
`손님`이 할당된 책임을 수행하는 도중에 스스로 할 수 없는 일이 있다면 다른 객체에게 이를 요청해야 한다. 이 요청이 바로 손님 객체에서 외부로 전송되는 메시지를 정의한다.

손님은 메뉴 항목에 대해서는 알지 못한다. 메뉴 항목은 고객이 아니라 메뉴판의 일부이다.
따라서 '메뉴 항목을 찾아라'라는 새로운 메시지가 등장한다.

![[Pasted image 20250617021609.png|400]]
이 경우 메시지에 ‘메뉴 이름’이라는 인자를 포함해 함께 전송한다. 
화살표 아래에 붙은 손님으로 향하는 작은 화살표는 이 메시지를 수신한 객체가 손님에게 무엇을 응답해야 하는지를 나타낸다. 
이 경우 ‘메뉴 항목을 찾아라’라는 메시지를 수신한 객체는 ‘메뉴 이름’에 대응되는 ‘메뉴 항목’을 반환해야 한다.

`메뉴 항목`을 찾을 책임으로는 `메뉴판` 객체가 가장 적절한 후보다.

![[Pasted image 20250617021726.png|400]]
자신이 주문한 `커피`에 대한 `메뉴 항목`을 얻었으니 이제 메뉴 항목에 맞는 커피를 제조해달라고 요청할 수 있다. 손님은 커피를 제조하는 메시지의 인자로 메뉴 항목을 전달하고 반환 값으로 제조된 커피를 받아야 한다.

![[Pasted image 20250617021731.png]]
바리스타는 스스로의 판단과 지식에 따라 행동하는 자율적인 존재로 커피를 제조할 것이다.  
협력에 필요한 객체의 종류와 책임, 주고받아야 하는 메시지에 대한 대략적인 윤곽이 잡혔다.  
남은 일은 메시지를 정제함으로써 각 객체의 인터페이스를 구현 가능할 정도로 상세하게 정제하는 것이다.

> 현실 속의 메뉴판은 자기 스스로 메뉴 항목을 찾지 않을 것이다. 현실 속에서 메뉴판은 손님에 의해 펼쳐지거나 닫혀지는 수동적인 존재다. 그러나 객체지향의 세계로 들어오면 수동적인 메뉴판이라는 개념은 더 이상 유효하지 않다. 객체지향 세계에서는 모든 객체가 능동적이고 자율적인 존재다. 소프트웨어 세상 속의 메뉴판은 현실 속의 메뉴판으로부터 모티브를 따왔지만 현실 속의 메뉴판보다 더 많은 일을 할 수 있다. 소프트웨어 객체는 현실 속의 객체를 모방하거나 추상화한 것이 아니다. 단지 의미를 쉽게 유추할 수 있도록 '은유'할 뿐이다. (현실 세계와 객체지향 세계의 다른 점을 너무 잘 보여주는 예시라고 생각한다.)

### 2. 인터페이스 정리하기
- 우리가 힘들여 얻어낸 것은 객체들의 인터페이스다.  
    객체가 수신한 메시지가 객체의 인터페이스를 결정한다.
- 각 객체를 협력이라는 문맥에서 떼어내어 수신 가능한 메시지만 추려내면 객체의 인터페이스가 된다.  
    객체가 어떤 메시지를 수신할 수 있다는 것은 그 객체의 인터페이스 안에 메시지에 해당하는 오퍼레이션이 존재한다는 것을 의미한다.
- 객체의 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이다.  
    협력을 통해 식별된 타입의 오퍼레이션은 외부에서 접근 가능한 공용 인터페이스의 일부이다.  
    따라서 인터페이스에 포함된 오퍼레이션 역시 외부에서 접근 가능하도록 공용(public)으로 선언되어 있어야 한다.

![[Pasted image 20250617022315.png|300]]
각 객체들이 수신하는 메시지는 객체의 인터페이스를 구성한다.  
이 정보를 토대로 코드를 구현한다면, 이렇게 될 것이다.

```java
class Customer {
	public void order(String menuName) {}
}

class Menuitem {
}

class Menu {
	public Menuitem choose(String name) {}
}

class Barista {
	public Coffee makeCoffee(Menuitem menuitem) {}
}

class Coffee {
	public Coffee(Menuitem menuitem) {}
}
```

### 3. 구현하기
클래스의 인터페이스를 식별했으므로 이제 **오퍼레이션을 수행하는 방법을 메서드로 구현**하자

#### Customer
`Customer`는 `Menu`에게 menuName에 해당하는 `Menuitem`을 요청하고, 이를 `Barista`에게 전달해서 커피를 요청한다.
```java
class Customer {
	public void order(String menuName, Menu menu, Barista barista) {
		Menuitem menuitem = menu.choose(menuName);
		Coffee coffee = barista.makeCoffee(menuitem);
	}
}
```

#### Menu
`Menu`는 menuName에 해당하는 `MenuItem`을 찾아야 하는 책임이 있다. 
이 책임을 수행하기 위해서는 `Menu`가 내부적으로 `Menuitem`을 관리하고 있어야 한다. 
간단하게 `Menu`가 `Menuitem`의 목록을 포함하게 하자. 

`Menu`의 choose() 메서드는 `MenuItem`의 목록을 하나씩 검사해가면서 이름이 동일한 `Menuitem`을 찾아 반환한다.
```java
class Menu {
	private List<MenuItem> items;

	public Menu(List<MenuItem> items) {
		this.items = items;
	}

	public Menuitem choose(String name) {
		for(MenuItem each : items) {
			if (each.getName().equals(name)) {
				return each;
			}
		}
		return null;
	}
}
```

#### Barista
`Barista`는 `Menuitem`을 이용해 커피를 제조한다.
```java
class Barista {
	public Coffee makeCoffee(Menuitem menuitem) {
		Coffee coffee = new Coffee(menuitem);
		return coffee;
	}
}
```

#### Coffee
`Coffee`는 생성자에서 `Menuitem` 정보를 기반으로 자신을 구성한다.
```java
class Coffee {
	private String name;
	private int price;

	public Coffee(Menuitem menuitem) {
		this.name = menuitem.getName();
		this.price = menuitem.cost();
	}
}
```

`Menuitem`은 이름과 가격을 반환할 수 있어야 한다.
```java
public class Menuitem {
	private String name;
	private int price;

	public Menuitem(String name, int price) {
		this.name = name;
		this.price = price;
	}

	public int cost() {
		return price;
	}

	public String getName() {
		return name;
	}
}
```

아래 그림은 커피 전문점 코드를 클래스 다이어그램으로 나타낸것이다.
![[Pasted image 20250617022636.png|600]]


## 코드의 세 가지 관점
### 코드는 세 가지 관점을 모두 제공해야 한다.
1. `개념 관점`
    - 개념 관점에서 코드를 바라보면 `Customer, Menu, MenuItem, Barista, Coffee` 클래스**가 있다.
    - 이 클래스들을 살펴보면 **커피 전문점 도메인을 구성하는 중요한 개념과 관계를 반영한다**는 사실을 알 수 있다.
    - 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 **변경을 관리하기 쉽고 유지보수성을 향상**시킬 수 있다.
    - 예를 들어 커피를 제조하는 과정을 변경해야 한다면 Barista 클래스가 커피를 제조할 것이라고 쉽게 유추할 수 있다.
2. `명세 관점`
    - 명세 관점은 **클래스의 인터페이스**를 바라본다.
    - 클래스의 public 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러낸다.
    - 공용 인터페이스는 외부의 객체가 해당 객체에 접근할 수 있는 유일한 부분이다.
    - 최대한 변화에 안정적인 인터페이스를 만들기 위해서는 **인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 한다.**
3. `구현 관점`
    - 구현 관점은 클래스의 내부 구현을 바라본다.
    - 클래스의 **메서드와 속성**은 구현에 속하며 공용 인터페이스의 일부가 아니다.
    - 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안된다.
    - 이것은 메서드와 속성이 철저하게 **클래스 내부로 캡슐화돼야 한다는 것을 의미**한다.

### 도메인 개념을 참조하는 이유
어떤 메시지가 있을 때 그 메시지를 수신할 객체를 어떻게 선택하는가?
- 첫번째 전략은 도메인 개념 중에서 가장 적절한 것을 선택하는 것
- 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유츄할 수 있다.
- 이것은 시스템의 유지보수성에 커다란 영향을 미친다.

소프트웨어는 항상 변한다.
ㅇ- 여러 개의 클래스로 기능을 분할하고 클래스 안에서 인터페이스와 구현을 분리하는 이유는 변경이 발생했을 때 코드를 좀 더 수월하게 수정하길 원하기 때문
- 소프트웨어 클래스가 도메인 개념을 따르면 변화에 쉽게 대응할 수 있다.

### 인터페이스와 구현을 분리하라
`인터페이스와 구현을 분리하라.`

- 인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동치는 취약한 설계를 얻을 수 밖에 없다.
- 실제로 훌륭한 설계를 결정하는 측면은 명세 관점은 객체의 인터페이스다.
- 명세 관점이 설계를 주도하게 하면 설계의 품질이 향상될 수 있다.
- **중요한 것은 클래스를 봤을 때 클래스를 명세 관점과 구현 관점으로 나눠볼 수 있어야한다는 것이다.**
- 캡슐화를 위반해서 구현을 인터페이스 밖으로 노출해서도 안되고, 인터페이스와 구현을 명확하게 분리하지 않고 흐릿하게 섞어놓아서도 안된다.






참고
https://glass-milkshake-24b.notion.site/Chapter-7-26410b3fc13a40d4bc252640169d49f0
https://yunyoung1819.tistory.com/214

