부록이지만 내용이 7장 못지 않게 좋았다.
---
## 추상화 기법
**추상화**는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다.  
**특성을 공유하는 객체들을 동일한 타입으로 분류하는 것**은 객체지향 패러다임에서 사용하는 **추상화 기법의 한 예**다.

### 중요한 추상화 기법의 종류
![[IMG-20250617023121974.jpeg|600]]
#### 1. 분류와 인스턴스화
- **분류**는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정
- 분류의 역은 범주로부터 객체를 생성하는 **인스턴스화** 과정이다.
#### 2. 일반화와 특수화
- **일반화**는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조
- 일반화의 역을 **특수화**라고 한다.
#### 3. 집합과 분해
- **집합**은 부분과 관련된 세부 사항을 숨기고, 부분을 사용해서 전체를 형성하는 과정을 가리킨다.
- 집합의 반대 과정은 전체를 부분으로 분리하는 **분해** 과정이다.
객체지향의 가장 큰 장점은 동일한 추상화 기법을 프로그램의 분석, 설계, 구현 단계에 걸쳐 일관성 있게 적용할 수 있다는 점이다.


## 개념의 인스턴스화
### 개념과 범주
- `개념`이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다.
	- 사람들은 공통점을 바탕으로 서로 다른 자동차라는 하나의 `개념`으로 분류할 수 있다.
- `분류`는 `객체`의 구체적인 세부사항을 숨기고 `인스턴스` 간에 공유하는 공통적인 특성을 기반으로 `범주`를 형성하는 과정이다.
	- 자동차 `범주`에 적용되는 `개념`은 '바퀴를 이용해 사람들을 한 장소에서 다른 장소로 운반하는 운송수단'이다.
	- 나무라는 `범주`에는 '푸른 잎과 갈색의 줄기를 가진 다년생 식물'이라는 `개념`을 적용할 수 있다.
	- 세상에 존재하는 서로 다른 상태를 가진 무수히 많은 자동차와 나무를 자동차/나무라는 `범주`로 묶음으로써 세상에 존재하는 복잡성을 낮출 수 있다.

### 타입
![[IMG-20250617024234643.jpeg|400]]
- 타입 : 개별 현상을 분류하는 하나의 개념 (타입 = 개념)  
- 타입을 객체의 분류 장치로서 적용할 수 있으려면 심볼, 내연, 외연 측면에서의 정의가 필요
    - **심볼** : 타입을 가리키는 간략한 이름이나 명칭 (ex. 자동차)
    - **내연** : 타입의 완전한 정의 (ex. 원동기를 동력원으로해서 사람이나 화물을 운반하는 기계)
    - **외연** : 타입에 속하는 모든 객체들의 집합 (ex. 승용차, 버스, 트럭)

### 외연과 집합
- 타입의 외연(객체)은 동시에 서로 다른 집합에 포함될 수 있음 (∵ 한 시점에 동일한 객체를 다양한 방식으로 인지)
    - **단일 분류** : 한 객체가 한 시점에 하나의 타입에만 속하는 것
    - **다중 분류** : 한 객체가 한 시점에 여러 타입에 속하는 것(ex. 어떤 컴퓨터는 데스크톱 컴퓨터인 동시에 사무용 컴퓨터일 수 있음) 
    - 대부분의 언어는 단일 분류만 지원 (∴ 한 객체는 오직 한 클래스의 인스턴스여야만 함)
    - `다중 분류 ≠ 다중 상속`! 혼동하면 안됨, `다중 상속`은 하나의 타입이 다수의 슈퍼타입을 가질 수 있지만 타입 정의를 생략할 수는 없음. `다중 분류`는 특정한 타입을 정의하지 않고도 하나의 객체가 서로 다른 타입의 인스턴스가 될 수 있음.

- 객체가 타입을 변경할 수 있다면? 
    - **동적 분류** : 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우
    - **정적 분류** : 객체가 자신의 타입을 변경할 수 없는 경우
    - 대부분의 언어는 정적 분류만 허용 (∴ 클래스로부터 인스턴스를 생성한 후 클래스를 변경할 수 없음)
- 다중 분류와 동적 분류 관점에서 도메인 모델의 초안을 만든 후 실제 구현에 적합하도록 단일 분류와 정적 분류 방식으로 객체들의 범주를 재조정하는 편이 분석과 구현 간의 차이를 메울 수 있는 가장 현실적인 방법  
    (다중 분류와 동적 분류를 구현할 수 있는 디자인 템플릿이 있지만, 유연성 측면에서 반드시 필요한 경우에만 사용해야 함)

### 클래스
- **객체지향 프로그래밍 언어**를 이용해 **타입을 구현하는 가장 보편적인 방법**은 **클래스**를 이용하는 것이다.
    - 여기서 '타입을 구현한다'라고 표현한 이유는 클래스와 타입이 동일한 개념이 아니기 때문
- 클래스는 타입을 구현하는 용도 외에도 코드를 재사용하는 용도로 사용되기도 한다.
- 클래스 외에도 인스턴스를 생성할 수 없는 추상 클래스나 인터페이스를 이용해 타입을 구현할 수도 있다.
- 클래스 기반의 객체지향 언어는 아리스토텔레스의 철학을 기반으로 한다.
    - 클래스는 객체가 공유하는 본질적인 속성을 정의한다.


## 일반화와 특수화
### 서브 타입
- 객체지향의 세계에서는 좀 더 일반적인 타입을 이용해 좀 더 세부적인 타입을 정의함으로써 타입 간의 계층 구조를 구축할 수 있다.
    - 어떤 타입이 다른 타입보다 일반적이라면 '**슈퍼타입(supertype)**'이라고 한다.
    - 어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 '**서브타입(subtype)**'이라고 한다.
    - 슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화다.

일반화와 특수화의 계층 구조에서 **서브타입**은 **슈퍼타입이 가진 본질적인 속성과 함께 자신만의 추가 속성을 가진다.**

- 서브타입은 슈퍼타입의 본질적인 속성을 모두 포함하기 때문에 계층에 속하는 모든 서브타입들이 슈퍼타입의 속성을 공유한다.
- 크레이그 라만은 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 100% 규칙과 Is-a 규칙을 준수해야 한다고 말한다.
    - `100% 규칙`: 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다. 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.
    - `Is-a 규칙`: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 이는 대개 영어로 서브 타입은 슈퍼타입이다(subtype is supertype)라는 구문을 만듦으로써 테스트할 수 있다.

### 상속
- 클래스 간의 상속을 사용하는 것은 `프로그래밍 언어를 이용해 일반화와 특수화 관계를 구현`하는 가장 일반적인 방법
- 일반화의 원칙은 한 타입이 다른 타입의 서브 타입이 되기 위해서는 슈퍼타입에 순응해야 한다는 것이다.
- 순응에는 `구조적인 순응`과 `행위적인 순응`의 두 가지 종류가 있다.
    - **구조적인 순응**: 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100%일치해야 한다. 
	    - ex) Person이 name이라는 속성을 가진다면 Person의 서브타입인 Employee 역시 name 이라는 속성을 가질 것이라고 기대할 수 있다.
    - **행위적인 순응**: 타입의 행위에 관한 것이며, 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다. 흔히 [[5. 객체 지향 설계 5원칙 - SOLID#LSP(Liskov Substitution Principle)： 리스코프 치환 원칙|리스코프 치환 원칙]]이라고도 한다. 
	    - ex) Person이 getAge()라는 메시지에 대한 응답으로 나이를 반환한다면 서브타입인 Employee 역시 getAge()라는 메시지에 대한 응답으로 나이를 반환해야 한다.

- 상속의 또다른 용도는 `코드 중복을 방지하고 공통 코드를 재사용하기 위한 언어적 메커니즘을 제공`하는 것이다. 2가지 용도로 사용될 수 있다.

|                                                                                            |                                                                                                     |
| ------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------- |
| **서브타이핑**                                                                                  | **서브클래싱**                                                                                           |
| - 서브클래스가 슈퍼클래스를 대체할 수 있는 경우  <br>- 설계의 유연성이 목표  <br>- 인터페이스 상속(interface inheritance)이라고 함 | - 서브클래스가 슈퍼클래스를 대체할 수 없는 경우  <br>- 코드의 중복 제거와 재사용이 목적  <br>- 구현 상속(implementation inheritance)이라고 함 |

- 만약 한 클래스가 다른 클래스를 상속한다면 **상속하는 타입**은 **부모 클래스의 데이터와 메서드를 사용하고, 수정하고, 확장**할 수 있다.
- 여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 **위임(delegation)**을 사용하는 것이다
    - 어떤 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 클래스의 부모 클래스로 위임한다.
    - 만약 부모 클래스에서도 메시지를 이해할 수 없다면 자신의 부모 클래스로 다시 메시지를 위임한다.
    - 클래스 간의 위임 사슬은 계층 내의 어떤 클래스가 메시지를 처리하거나 최상위 부모 클래스에 위임할 때까지 계속된다.


## 집합과 분해
### 계층적인 복잡성
- 집합 : 안정적인 형태의 부분으로부터 전체를 구축하는 행위
    - 불필요한 세부 사항 추상화 ⇒ 복잡성↓
    - 추상화 메커니즘인 동시에 캡슐화 메커니즘
- 분해 : 전체를 부분으로 분할하는 행위
- 합성 관계 ⇒ 객체와 객체 사이의 전체-부분 관계 구현 (내부에 포함된 객체들의 존재를 감춤으로써 내부 구조 추상화)  
    - 합성 관계 ↔︎ 연관 관계
    - 합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거됨
    - 연관 관계로 연결된 객체는 독립적으로 제거될 수 있음 (생명주기와 관련된 어떤 제약도 없음)

### 합성관계
![[IMG-20250617025639795.jpeg|400]]
- 상품 주문을 생각해보자.
    - 여러 상품을 한번에 주문할 수 있다.
    - 이때 각 상품을 몇 개 주문했는지를 가리켜 주문 항목이라고 한다.
    - 각 주문 항목은 주문과 독립적으로 존재할 수 없다. 주문 항목은 반드시 어떤 한 주문의 일부로 생성되기 때문에 주문의 일부여야 한다.
    - 객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 **'합성 관계'**를 사용한다.
![[IMG-20250617025652783.jpeg|400]]
- 상품과 주문 항목 사이에도 관계가 존재하지만 상품은 주문 항목의 일부가 아니다.
    - 따라서 주문과 주문 항목 사이의 관계는 전체와 부분 간의 관계를 나타내는 합성 관계인데 비해
    - 주문 항목과 상품 간에는 단순한 물리적 통로가 존재한다는 사실만 나타낸다. 이를 **연관관계**라고 한다.
- 합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거된다.
- 합성 관계는 생명주기 측면에서 연관 관계보다 더 강하게 객체들을 결합한다.

### 패키지
- 합성 관계를 이용해 커다란 객체 그룹을 단순화하더라도 클래스의 수가 많아지면 얽히고 설킨 클래스 간의 의존성을 관리하는 일은 악몽으로 변해 간다.
- 소프트웨어는 물리적인 형체라는 것이 존재하지 않으므로 구조를 단순화하기 위해서는 **서로 관련성이 높은 클래스 집합을 논리적인 단위로 통합**해야 한다.
- 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 **클래스 집합**을 **하나의 논리적인 단위로 묶는 구성 요소**를 **패키지(package)** 또는 **모듈(module)**이라고 한다.
- 패키지를 이용하면 시스템의 전체적인 구조를 이해하기 위해 한 번에 고려해야 하는 요소의 수를 줄일 수 있다.
- 또한 개별 클래스가 아닌 클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있다.
- 합성 관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화하는 것처럼 패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화한다.




참고
https://yejinlife.tistory.com/entry/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4-%EB%B6%80%EB%A1%9DA-%EC%B6%94%EC%83%81%ED%99%94-%EA%B8%B0%EB%B2%95