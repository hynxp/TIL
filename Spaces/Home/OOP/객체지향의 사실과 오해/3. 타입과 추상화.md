## 추상화를 통한 복잡성 극복
이 책에서는 서두로 런던의 지하철 노선도를 예로 시작한다.
초기의 지하철 노선도는 실제와 유사한 물리적인 지형 위에 구불구불한 운행 노선과 불규칙적인 역 간의 거리를 사실적으로 묘사하고 있었다. 문제는 이런 정보가 오히려 승객들로 하여금 노선도를 이해하기 어려웠다는 점이다.

![[IMG-20250506203940330.png|600]]
1927년 스팅모어가 디자인한 초기의 디자인은 지형을 고려하여 노선도를 설계했다.

![[IMG-20250506204101176.png]]
하지만 1933년 헤리 백은 사실적인 지형과 축척(지도 상에 나타난 거리와의 비율)을 무시하고 역 사이의 연결성에만 집중했다.

이 지하철 노선도의 핵심은 지도가 당연히 가져야 한다고 생각되는 '정확성'을 버리고 그 '목적'에 집중한 결과다.
헤리 백은 인터뷰에서 다음과 같이 말했다.
**"지하철을 갈아탈 때 지형 때문에 골치 아플 필요가 있을까요? 지형은 중요한 것이 아닙니다. 중요한 것은 연결, 즉 열차를 갈아타는 것입니다."**

헤리 백은 지하철을 이용하는 승객들을 면밀하게 관찰한 후 승객이 꼭 알아야 하는 사실만 정확하게 표현하고 몰라도 되는 정보는 무시함으로써 이해하기 쉽고 단순하며 목적에 부합하는 지하철 노선도를 창조해 낼 수 있었다.
**즉, 지하철 노선을 추상화한 것이다.**


## 분류는 추상화를 위한 도구다.
추상화란 어떤 양상, 세부 사항, 구조를 좀 더 **명확하게 이해하기 위한 목적**을 가지고 특정 절차나 물체를 **의도적으로 생략하거나 감춤으로써** 복잡도를 극복하는 방법이다.

**추상화를 하여 복잡성을 줄이는 방법**은 크게 두가지가 있다.

1. 구체적인 사물 간의 공통점은 취하고 차이점을 버리는 일반화를 통해 단순화하는 것이다.
2. 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거해 단순화하는 것이다.


## 타입
### 타입은 개념이다.
타입의 정의는 개념의 정의와 완전히 동일하다. 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어, 관념을 의미한다.
어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 

어떤 데이터는 다른 데이터와 사칙연산이 가능하다. 이 데이터를 숫자형으로 **분류**했다.  
어떤 데이터는 어떤 사실에 대한 참/거짓을 이야기 할 수 있다. 이 데이터를 논리형으로 **분류**했다.

### 타입 시스템의 목적
타입 시스템의 목적은 메모리 안의 모든 데이터가 비트열로 보임으로써 야기되는 혼란을 방지하는 것이다.

데이터를 이용해 수행할 수 있는 작업을 연산자라고 한다.  
데이터 타입을 통해 우리는 2가지를 알 수 있다.

1. 어떤 데이터에 **어떤 연산자를 적용할 수 있느냐**가 그 **데이터의 타입을 결정**한다.
2. 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 **외부로부터 철저하게 감춰진다.**

### 객체와 타입
우리는 프로그래밍을 하며 **객체를 데이터처럼 사용**한다. 
그렇다면 객체는 데이터인가? 그렇지 않다.

**객체에서 중요한 것은 객체의 행동이다.** 
상태는 행동의 결과로 초래된 부수효과를 쉽게 표현하기 위해 도입한 추상적인 개념일 뿐이다.
객체를 창조할 때 가장 중요하게 고려해야 하는 것은 객체가 이웃하는 객체와 협력하기 위해 어떤 행동을 해야 할지 결정하는 것이다.

즉, 객체가 협력을 위해 어떤 책임을 지녀야 하는지를 결정하는 것이 객체지향 설계의 핵심이다.

데이터 타입에 관해 두 가지 조언을 기억하자.
1. 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다. 어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류할 수 있다. 
2. 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.

### 행동이 우선이다.
어떤 객체를 다른 객체와 동일한 타입으로 분류하는 기준은 무엇인가?
그 객체가 타입에 속한 다른 객체와 동일한 행동을 하기만 하면 된다. 
(여기서 난 동일한 행동을 함수 즉, 메서드로 이해했다.)

여기서 **동일한 행동이란 동일한 책임을 의미하며, 동일한 책임이란 동일한 메시지 수신을 의미**한다.
따라서 동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 이를 처리할 수 있다.

> 예를 들어 Shape이라는 타입(인터페이스 혹은 추상 클래스)이 있고, 그 하위 타입인 Circle, Rectangle이 있다고 하자. 
> 이 객체들은 내부적으로 저장하는 데이터가 완전히 다르다. (반지름, 가로/세로 등)
> 하지만 **draw()라는 동일한 메시지(메서드)를 받을 수 있고**, 각자 다른 방식으로 처리할 수 있다.

다만 내부 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수밖에 없다.
이것은 **다형성**에 의미를 부여한다.

> Circle은 원을 그리는 방식으로, Rectangle은 사각형을 그리는 방식으로 draw()를 처리한다.
> 이렇게 **같은 이름의 메서드를 다른 방식으로 처리하는 것**, 이것이 바로 **다형성의 핵심**이다.

**즉, 다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 뜻한다.**

> -raw()라는 메서드를 호출했을 때, 실제 어떤 객체냐에 따라 다르게 작동할 수 있다는 것이 **다형성**이다.

동일한 메시지를 서로 다른 방식으로 처리하기 위해서 객체들은 동일한 메시지를 수신할 수 있어야 하기 때문에 결과적으로 다형적인 객체들은 동일한 타입(또는 타입 계층)에 속하게 된다.

> draw()라는 메시지를 처리할 수 있으려면 모든 객체가 **Shape이라는 타입(또는 인터페이스)**을 구현해야 한다.


또한, 데이터의 내부 표현 방식와 무관하게 행동만이 고려 대상이라는 사실은 외부에 데이터를 감춰야 한다는 것을 의미한다. 따라서 훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다. 이 원칙을 **캡슐화**라고 한다.

"객체를 결정하는 것은 행동이다. 데이터는 단지 행동을 따를 뿐이다. 이것이 객체를 객체답게 만드는 가장 핵심적인 원칙이다"


## 타입의 계층
### 일반화 특수화
일반적인 타입이란 특수한 타입이 가진 모든 행동들 중 **일부 행동만** 가지는 타입을 가리킨다.

### 슈퍼타입과 서브타입
일반적인 타입을 슈퍼타입, 특수한 타입을 서브타입이라고 한다.
이름이 중요한 것이 아니라. **두 타입 간의 관계가 행동에 의해 결정**된다는 점이 중요하다.

어떤 객체가 다른 객체보다 더 일반적인 상태를 표현하거나 더 특수한 상태를 표현한다고 해서 두 객체가 속하는 타입 간에 일반화/특수화 관계가 성립하는 것은 아니다.
중요한 것은 객체가 내부에 보관한 데이터가 아니라 객체가 외부에 제공하는 행동이다.

서브타입은 슈퍼타입의 행위에 추가적으로 특수한 자신만의 행동을 추가하는 것이므로 슈퍼타입의 행동은 서브타입에게 자동으로 **상속**된다.


## 정적 모델
### 타입의 목적
왜 타입을 사용해야 하는가?
타입을 사용하는 이유는 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기 너무 어렵기 때문이다.

우리는 앨리스가 가질 수 있는 모든 경우의 키 값을 나열하는 대신 앨리스의 키가 임의의 값을 가질 수 있다는 사실만을 생각하면 단순해진다.
즉, 앨리스에 대해 생각할 때 키가 100cm, 80cm, 3m가 될 수 있다라는 사실은 뒤로 미루고, 단지 앨리스가 변경되는 키라는 상태를 가진다고 단순화하면 그만인 것이다.

### 그래서 결국 타입은 추상화다
이런 관점에서 타입은 추상화다. 읽으면서 '어떤 속성을 추상화 한것이 상태의 타입 아닌가?'라고 생각했는데 바로 이 소제목이 나와서 소름돋았다 ㄷㄷ

결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수있는 효과적인 방법인 것이다.

### 동적 모델과 정적 모델
객체지향 어플리케이션을 설계하고 구현하기 위해서는 **객체 관점의 동적 모델과 타입 관점의 정적 모델을 적절히 혼용**해야한다.

예를 들어 프로그래밍을 하며 클래스를 작성하는 시점에는 시스템을 정직인 관점에서 접근하는 것이다.  하지만 디버깅을 하는 동안에는 객체의 동적인 모델을 탐험하는 것이다.

### 클래스
객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다.
따라서 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다. 
**클래스와 타입은 동일한 것이 아니다.**

> 클래스는 “객체를 어떻게 만들 것인지”를 정의한 **구현체**고, 타입은 "객체가 어떤 행위를 할 수 있는지"를 설명하는 것이다.

타입은 객체를 분류하기 위해 사용하는 개념이다. 반면 클래스는 단지 타입을 구현할 수 있는 여러 
구현 메커니즘 중 하나일 뿐이다.

> **타입은 객체가 어떤 메시지를 수신할 수 있는지를 기준으로 정의되고**, 클래스는 그것을 **어떻게 구현할 것인가에 대한 세부사항**이다. (핵어렵다)

실제로 자바스크립트 같은 프로토타입 기반의 언어에는 클래스가 존재하지 않는다.

지금 객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이라는 사실만 기억하면 된다.

> bark()라는 메서드를 가졌다면, 이 객체는 “bark할 수 있는 타입”으로 분류된다

결국 객체지향에서 중요한 것은 동적으로 변하는 객체의 '상태'와 상태를 변경하는 '행위'다.