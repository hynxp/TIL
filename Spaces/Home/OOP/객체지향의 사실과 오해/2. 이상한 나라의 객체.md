## 시작
아이의 가림막 테스트를 통해 인지능력에 대한 이야기로 챕터2를 시작했다.

사물을 인지할 수 있는 아기처럼 사람은 무언가를 인지할 수 있는 인지능력을 가지고 있다. 객체 지향은 세상을 **자율적이고 독립적인 객체**들로 분해할 수 있는 인간의 기본적인 이 인지능력에 기반을 두고 있다.


인간은 좀 더 단순한 객체들로 주변을 분해함으로써 자신이 몸 담고 있는 세상을 이해하려 한다. 그렇기에 객체란 인간이 분명하게 **인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것**이다.

하지만, 유사성은 여기까지다. 객체는 현실세계를 모방하는 것이 아닌, **새로운 세계를 창조하는 것**. 사람의 손길 없이 스스로 불을 밝힐 수 없는 전등과 다르게 SW세계에선 전등은 외부의 도움없이도 처리가 가능하다. 우리는 이렇게 유사하면서도 이질적인 객체지향의 세계를 바라볼 수 있다.

_마치 이상한 나라의 앨리스처럼!_

앨리스는 어떠한 장소를 가기위해 어떠한 행위를 함으로써 자신의 키를 늘리고 줄일 수 있다.

앨리스의 키를 변화시키는 것은 앨리스의 행동. 그 행동에 따라 상태가 변하게 되는 것이다. 자신의 상태에 따라 행동의 결과도 변할 수 있는데 이것을 한마디로 **‘행동의 결과는 상태에 의존적이다’** 라고 볼 수 있다.

또한, 어떤 행동의 성공 여부는 이전에 어떤 행동들이 발생했는지에 따라 달라진다. 그러므로 행동 간의 순서도 중요한 요소가 될 수 있다는 것이다.

앨리스가 이렇듯 어떤 행동을 하든 어떤 상태가 되는 앨리스는 결국 앨리스이다. 유일한 존재로 식별이 가능하다는 것.

이 내용을 정리해 보자면,

- _앨리스는 상태를 가지며 상태는 변경 가능하다._
- _앨리스의 상태를 변경시키는 것은 앨리스의 행동이다._
    - _행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다._
    - _행동의 순서가 결과에 영향을 미친다._
- _앨리스는 어떤상태에있더라도 유일하게 식별 가능하다._

객체의 특징과 앨리스의 특징은 중요한 공통점 몇가지를 공유한다.

## 객체, 그리고 소프트웨어 나라
이전 챕터엔 **책임, 역할, 협력**에 대해 이야기 했다면, 이번 챕터의 주제는 **상태, 행동, 식별자** 이다.

앨리스는 상태, 행동, 식별자를 지닌 실체다. 객체도 이와 마찬가지다.

> _객체란 식별 가능한 개체 또는 사물이다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다._

### 상태
_왜 상태가 필요한가?_

이 질문에 **상태란 필수불가결한 것**이라고 말할 수 있다. 책과 다른 예제를 들어보자면, 깁스를 한 상태에서 내게 달려보라는 요청이 들어온다면, 내가 육상선수라 하여도 나는 그 요청을 거절할 것이다. 달릴 수 없는 상태니 말이다.

이렇듯 **상태를 알면** 과거에 얽매이지 않고 **현재를 기반으로 객체의 행동 방식을 이해**할 수 있다.

### 상태와 프로퍼티

_프로퍼티란?_

객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티라고 한다. 일반적으로 프로퍼티는 변경되지 않기 때문에 **고정적이며**, 프로퍼티 값은 변경될 수 있기 때문에 **동적**이다.


앨리스가 음료수를 들고 있다면 앨리스 객체와 음료 객체는 밀접한 관계를 지니게 된다. 하지만 앨리수가 음료수를 버리게 된다면? 서로의 상관관계가 사라지는 것이다.

사진을 확인하면, 선이 사라진 것을 볼 수 있다. 이처럼 사라진 선을 객체와 객체 사이의 의미있는 연결이라 하여 **링크(Link)**라고 부른다. 객체와 객체 사이에는 링크가 존재해야만 요청을 송수신할 수 있다. 즉, 링크를 통해서만 메시지를 주고 받을 수 있다.

자, 이제 상태에 대해 정의해보자면,

> _상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 **정적인 프로퍼티와 동적인 프로퍼티 값**으로 구성된다. 객체의 프로퍼티는 **단순한 값(속성)과 다른 객체를 참조하는 링크**로 구분할 수 있다._

명심하자, 객체는 스스로 상태를 변경해야한다. 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지하기 때문이다.

### 행동

### **상태와 행동**

객체는 자발적인 행동에 의해서 상태가 바뀐다. 행동이 부수 효과를 초래한다는 말이기도 하다. 이 부수효과 개념을 이용하면 객체의 행동을 상태 변경의 관점에서 쉽게 기술이 가능하다.

상태와 행동 사이에는 다음과 같은 관계가 있다.

- _객체의 행동은 상태에 영향을 받는다._
- _객체의 행동은 상태를 변경시킨다._

이것은 상태라는 개념을 이용해 다음의 두 가지 관점에서 서술할 수 있다.

- _상호작용이 현재의 상태에 어떤 방식으로 의존하는가_
- _상호작용이 어떻게 현재의 상태를 변경시키는가_

### 협력과 행동

객체가 다른 객체와 협력하는 유일한 방법은 **‘요청’**을 보내는 것이다. 그렇다면 요청을 수신한 객체는 적절한 방법에 따라 행동하지 않겠는가? 따라서 **행동은 객체가 협력에 참여할 수 있는 유일한 방법**이다.

객체의 행동으로 하여금 상태가 변경된다. 그런데 그 행동이 다른 객체의 상태 변경을 유발시킬 수도 있다.

정리하면 객체의 행동으로 인해 발생하는 결과는 두가지 관점에서 설명할 수 있다.

- _객체 자신의상태변경_
- _행동내에서 협력하는다른 객체에 대한 메시지전송_

자 이제 행동을 다음과 같이 정의해보자.

> _행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 객체는 **자신의 상태를 변경하거나 다른 객체에게 메시지를 전달**할 수 있다. 객체는 행동을 통해 다른 객체와의 **협력에 참여하므로 행동은 외부에 가시적**이어야 한다._

### 상태 캡슐화

위의 사진을 보자. 앨리스가 음료수를 마셨고, 음료에게 마셨다는 메시지를 보내는 것을 알 수 있다. 그럼 둘의 상태를 확인할 수 있는가? 이 사진만 봐서는 어떤 상태인지는 알 수 없다. 서로 어떤 메시지를 주고 받았는지 알 수 있을 뿐.

이것이 **캡슐화**이다. 자신의 상태를 외부가 알 수 없게 숨기는 것을 뜻한다.

상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 **객체의 자율성을 높이고 협력을 단순하고 유연하게** 만든다. 이것이 상태를 캡슐화해야 하는 이유다.

### 식별자

**서로 구별할 수 있는 특정한 프로퍼티**가 객체 안에 존재하는데, 이 프로퍼티를 식별자라 한다.

값과 객체의 명확한 차이는 식별자 유무이다. 객체는 식별자를 가지는 반면, 값은 식별자를 가지고 있지 않다.

값의 경우. _두 인스턴스 상태가 같다면 그저 같다고 판단_한다. 상태에 따라 같은지 확인할 수 있는 이 성질을 **동등성**이라 부른다.

이렇게 할 수 있는 이유는 **값의 상태가 변하지 않기** 때문이다. 그렇기 때문에 두 값이 같다면 언제까지라도 동등한 상태를 유지할 것이다. 이와 같은 이유로 값은 식별자를 가지고 있을 필요가 없다.

하지만 객체의 경우, 시간에 따라 **변경되는 상태**를 포함하고, 행동을 통해 상태를 변경한다. 따라서 가변이기 때문에 이를 식별할 수 있는 무언가가 필요하다.

이렇게 식별자를 기반으로 객체가 같은지 판단할 수 있는 성질은 **동일성**이라고 한다.

자, 이제 식별자를 정리해 보자면,

> _식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다. **값**은 식별자를 가지지 않기 때문에 **상태를 이용한 동등성 검사**를 통해 두 인스턴스를 비교해야 한다. **객체**는 상태가 변경될 수 있기 때문에 **식별자를 이용한 동일성 검사**를 통해 두 인스턴스를 비교할 수 있다._

Integer도 클래스로부터 생성된 객체인데 그럼 애도 식별자를 가지고 있을까?

그래서 나온 용어가 **참조객체** 또는 **엔티티** 그리고 식별자를 가지고 있지 않는 **값 객체**이다.

여기까지, 객체의 중요한 특성인 **상태, 행동, 식별자**에 관련된 이야기였다. 이 내용들을 한번 요약해자.

- _객체는 상태를 가지며 상태는 변경 가능하다.-_
- _객체의 상태를 변경시키는 것은 객체의 행동이다._
    - _행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.-_
    - _행동의 순서가 실행 결과에 영향을 미친다_
- _객체는 어떤 상태에 있더라도 유일하게 식별 가능하다_

## 기계로서의 객체

개발자들은 이 객체의 상태를 조회하고, 객체의 상태를 변경한다. 객체의 상태를 조회하는 작업을 **쿼리**라고 하며, 객체의 상태를 변경하는 작업을 **명령**이라고 한다. 객체가 외부에 제공하는 행동의 대부분은 쿼리와 명령으로 구성된다.

메이플에 비유해보면 사용자는 방향키로 캐릭을 움직일 수 있고**(명령)** 인벤토리나 정보창을 열어 캐릭터의 상태를 조회할 수 있다.**(쿼리)** 이것은 객체의 행동을 유발하기 위해 메시지를 전송하는 것과 유사하다.

객체에 접근할 수 있는 유일한 방법은 객체가 제공하는 행동뿐이라는 점이다. 즉, 사용자는 객체가 제공하는 **명령 버튼과 쿼리 버튼으로 구성된 인터페이스를 통해서만 객체에 접근**할 수 있다. ~~내가 메이플을 하고 있다면 나와 캐릭터는 링크를 통해 연결되어 메시지를 주고 받으며 협력하고 있는 것.~~ _**이 점은 캡슐화를 강조하고 있다.**_


메이플에서 사냥을 하고 있는데, 같은 캐릭터가 지나간다. 이 둘이 같다고 표현할 수 있겠는가? 이것은 각각의 객체. _**즉 식별이 가능하다는 점이다.**_

책에서는 이 내용을 기계에 비유했다. 하지만, 나는 이 내용을 보자마자 메이플이 떠오르더라.

## 행동이 상태를 결정한다. ‼️
상태를 중심으로 객체를 바라보는 것은 함정이다!

_그렇다면 왜 상태를 중심으로 보면 안될까?_

### 첫번째

_상태를 먼저 결정할 경우 캡슐화가 저해된다._ 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다.

### 두번째
_객체를 협력자가 아닌 고립된 섬으로 만든다._ 불행하게도 상태를 먼저 고려하는 방식은 협력이라는 문맥에서 멀리 벗어난 채 객체를 설계하게 함으로써 자연스럽게 협력에 적합하지 못한 객체를 창조하게 된다.

### 세번째
_객체의 재사용성이 저하된다._ 상태에 초첨을 맞추면 다양한 협력에 참여하기 어렵기 때문에 재사용성이 저하될 수밖에 없다.

따라서 행동에 초점을 맞춰야한다. 행동이 협력에 참여하는 유일한 방법이기 때문이다. **객체가 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이다.** 그렇기에 객체의 행동을 결정하고 그 후에 행동에 적절한 상태를 선택해야한다.

객체가 협력에 참여하면, 완수해야하는 책임이 생긴다. 따라서 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야한다.

이 책에서 살펴볼 **책임一주도 설계(Responsibility—Driven Design, RDD)[Wirfs—Brock 2003]**는 협력이라는 문맥 안에서 객체의 행동을 생각하도록 도움으로써 응집도 높고 재사용 가능한 객체를 만들 수 있게 한다

아무튼 이 모든 내용중에 제일 중요하고 결국 핵심이 되는 것은 이것이다.

> _**“행동이 상태를 결정한다”**_

## 은유와 객체(마무리)


객체지향을 현실 세계에 은유할 수 있지만, 그렇다고 현실 세계를 모방하는 것은 아니다. 객제지향을 현실 세계의 추상화라고 표현하는 것은 잘못됐다는 것이다.

실제 객체지향은 현실 세계와 다른 양상을 띈다. 그 의미는 비슷하더라도 현실을 모방한다는 것은 오해일 뿐이다.

### 의인화

그렇다면 현실세계와 객체지향세계의 큰 차이점은 무엇일까?

소프트웨어 세계의 객체는 능동적으로 변한다. 초능력을 가지는 것 처럼 새로운 능력을 가질 수도 있고, 또 다른 존재가 될 수도 있다. 어쨌든 현실 세계의 물체가 소프트웨어 세계에서는 전지전능한 존재가 되는 것. 이것을 **의인화** 라고 부를 수 있다.

그러므로 모방한 것이 아닌, 현실의 모습을 조금 참조할 뿐, 새로운 세계를 창조한다.