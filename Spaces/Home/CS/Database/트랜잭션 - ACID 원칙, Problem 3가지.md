## 트랜잭션(Transaction)이란
트랜잭션은 데이터베이스에서 하나의 작업 단위를 의미한다.

### 예제
은행에서의 계좌이체를 생각해보자. 만약 한 계좌에서 다른 계좌로 1,000원을 이체하는 작업을 트랜잭션으로 본다면, 다음과 같은 단계로 나뉜다:

1. A 계좌에서 1,000원을 **출금**한다.
2. B 계좌에 1,000원을 **입금**한다.

계좌이체라는 행위를 출금, 입금이라는 두 작업으로 이루어진다.
이 두 작업은 반드시 함께 수행되어 둘 다 성공하거나 둘 다 실패해야 한다. 만약 A 계좌에서 돈이 빠져나갔는데 B 계좌에 입금되지 않는다면, 데이터가 불일치하게 되어 문제가 발생할 것이다.
이 과정을 동시에 묶는 방법이 바로 트랜잭션이다.

### 트랜잭션의 주요 특성 (ACID)
트랜잭션은 데이터의 무결성을 보장하기 위해 **ACID 특성**을 만족해야 한다. 
ACID는 다음의 4가지 특성으로 구성된다

#### Atomicity(원자성) 
트랜잭션이 모든 작업을 완벽히 실행하거나 전혀 실행하지 않아야 함을 의미한다. 즉, 작업이 중간에 실패하면 전체 트랜잭션이 롤백되어야 한다.

#### Consistency(일관성) : 
트랜잭션이 완료되면 데이터베이스는 항상 일관된 상태를 유지해야 한다.

#### Isolation(고립성) : 
둘 이상의 트랜잭션이 동시에 실행되고 있을 때, 각 트랜잭션은 서로 간섭 없이 독립적으로 수행되어야 한다.
즉, 하나의 트랜잭션이 완료되기 전에는 다른 트랜잭션이 그 데이터를 변경할 수 없어야 한다.

하지만 고립성을 보장하기 위해 무차별적으로 Lock을 걸다보면 대기시간이 매우 길어지므로 트랜잭션은 최소한으로 사용해야 한다.

#### Durability(지속성) : 
트랜잭션이 성공적으로 완료된다면, 그 결과가 데이터베이스에 영구적으로 반영되어야 한다.


### 트랜잭션 상태
트랜잭션은 작업이 진행됨에 따라 다음과 같은 상태를 거친다
![[IMG-20241107105119851.png]]

#### 활성(Active)
트랜잭션이 시작되어 작업이 진행 중인 상태

#### 부분 완료(Partially Committed)
트랜잭션의 마지막 명령이 실행된 직후의 상태, 그러나 아직 commit된 것은 아니며 시스템 장애가 발생할 경우 트랜잭션이 취소될 수 있다.

`commit` : 트랜잭션을 완료하고, 모든 변경 사항을 데이터베이스에 **영구적으로 반영**하는 연산

### 완료(Committed)
트랜잭션이 성공적으로 완료되어 모든 변경 사항이 데이터베이스에 영구적으로 반영된 상태

#### 실패(Failed)
트랜잭션에 오류가 발생해 더 이상 진행할 수 없는 상태

#### 철회(Aborted)
트랜잭션이 실패하고 롤백되어 데이터베이스가 원래 상태로 복구된 상태

`rollback` : 트랜잭션을 중단하고, 이미 수행된 모든 변경 사항을 **되돌리는** 연산



## 트랜잭션에서 발생할 수 있는 문제들
트랜잭션이 동시에 여러 개 수행될 때, 트랜잭션 간의 상호작용으로 인해 **데이터 일관성**과 **정확성**에 문제가 발생할 수 있다. 대표적인 트랜잭션 문제로 3가지가 있다.

### 1. Dirty Read Problem
**한 트랜잭션이 커밋되지 않은 다른 트랜잭션의 데이터를 읽을 때 발생**한다.
이 문제는 트랜잭션이 아직 완료되지 않아 확정되지 않은 데이터를 다른 트랜잭션에서 읽을 수 있게 될 때 발생한다.

![[IMG-20241107105119928.png]]
트랜잭션 1에서 `data2` 를 insert하고 커밋하지 않은 상태에서 
트랜잭션 2가 `data2` 를 읽으면 `data2`는 커밋될지 롤백될지 알 수 없다.

### 2. Non-repeatable Read Problem
한 트랜잭션이 **같은 데이터를 2번 이상 조회했을 때 그 값이 다르게 나오는 경우**를 말한다.
이는 한 트랜잭션 도중 다른 트랜잭션이 데이터를 `수정/삭제`하고 커밋할 경우 발생할 수 있다.

![[IMG-20241107105120811.png]]

트랜잭션이2가 key가 2인 데이터의 값을 "updated"로 수정하고 커밋했다.
트랜잭션1은 수정 전에 데이터를 select한 결과와 수정 후의 select 결과가 다르게 조회한다.

### Phantom Read Problem
한 트랜잭션 내에서 **같은 쿼리를 여러 번 실행했을 때, 처음에는 없던 데이터가 나중에 조회되는 경우**를 말한다.

![[IMG-20241107105121009.png]]
트랜잭션1이 데이터를 조회하는 도중에 트랜잭션2가 `data3`을 insert하고 커밋할 경우 
트랜잭션1에서는 처음에 안 보였던 Phantom(유령, 환상)데이터가 나타나게 된다.
보통 데이터의 `삽입`이 발생했을 경우 발생한다.





참고
[트랜잭션의 격리성 문제 - Dirty Read / Non-Repeatable Read / Phantom Read](https://innovation123.tistory.com/166#2.%20Non-Repeatable%20Read-1)
