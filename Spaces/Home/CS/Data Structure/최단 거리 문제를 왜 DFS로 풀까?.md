![[IMG-20250302011515193.png|200]]
트리에서 최단 거리를 구할 때 DFS를 사용하는 문제를 풀 때, 강의에서 강사가 언급한 부분이 있다.
**"DFS로 최단 거리를 구할 때는 자식이 항상 둘 다 있는 완전한 이진 트리일 경우에만 제대로 동작한다."** 
이게 무슨말일까?

DFS로 트리의 최단 거리를 구할 때, 트리가 항상 완전한 이진 트리라는 보장이 없다면 코드가 예상대로 동작하지 않는 경우가 발생한다.  

특히, **한쪽 자식만 있는 경우**나 **자식이 아예 없는 경우**가 문제의 원인이 된다.

### 예시 트리 (비대칭 트리)
```
      1
     /
    2
   /
  3
```
위처럼 한쪽 자식만 존재하는 트리에서는, DFS 기반의 최단 거리 탐색 코드가 제대로 작동하지 않을 가능성이 높다.


트리에서 DFS로 최단 거리를 구할 때 보통 다음과 같은 코드를 많이 사용한다.
```java
int DFS(int level, Node root) {
    if (root.lt == null && root.rt == null) {
        return level;
    }
    return Math.min(DFS(level + 1, root.lt), DFS(level + 1, root.rt));
}
```
이 코드가 문제없이 동작하려면, 노드의 왼쪽 자식과 오른쪽 자식이 **둘 다 존재하는 경우**여야 한다.  
완전한 이진 트리라면 이 조건을 자연스럽게 만족하기 때문에 문제가 없다.  
하지만 한쪽 자식만 있거나 자식이 아예 없는 경우에는 다음과 같은 문제가 발생한다.

- 왼쪽 자식만 있을 때, `DFS(level + 1, root.rt)`에서 `root.rt`가 `null`이라 예외가 발생할 수 있다
- Math.min()으로 최소 레벨을 비교할 때, 양쪽 값이 모두 있어야 하는데 한쪽이 `null`인 경우 처리하기가 애매해진다

### 한쪽 자식만 있는 경우의 문제 예시
아래 트리처럼 한쪽 자식만 있는 경우를 생각해본다.
```
    1
     \
      2
```

위 트리에서 DFS로 최단 거리를 구하는 코드를 돌리면, 다음과 같은 상황에 부딪히게 된다.
```java
int DFS(int level, Node root) {
    if (root == null) return Integer.MAX_VALUE;
    if (root.lt == null && root.rt == null) {
        return level;
    }
    return Math.min(DFS(level + 1, root.lt), DFS(level + 1, root.rt));
}
```
위 코드에서는 자식이 하나만 있는 경우를 `null`로 처리하고, `Integer.MAX_VALUE`를 반환하도록 했지만, 이런 방식은 매우 불편하다.

- 왜냐하면 **리프 노드로 가는 경로 중 일부만 탐색할 수 있다**는 문제가 생긴다.
- 실제로는 자식이 하나만 있어도 그 경로로 탐색을 계속 진행해야 하는데, `null`이면 강제로 큰 값으로 처리해버리기 때문이다.

### DFS로 최단 거리 구할 때 자식 수 조건이 중요한 이유
강사가 말한 핵심은 이런 것 같다.

**완전한 이진 트리에서는 자식이 항상 두 개라서 Math.min()으로 쉽게 최소 거리를 구할 수 있다**  
반면 한쪽 자식만 있는 경우는 추가적인 예외 처리가 반드시 필요하고, 이 과정에서 코드가 복잡해진다.

 이러한 이유로 최단 거리를 구할 때 **DFS보다 BFS를 사용**하는 것이다.