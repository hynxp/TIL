효율적인 데이터 저장과 검색을 위해 자주 사용되는 개념 중 하나가 바로 해싱(Hashing)이다. 해싱은 자바에서 특히 중요하게 다뤄지는 기술로, `HashMap`과 같은 자료구조의 핵심적인 동작 원리로 자리 잡고 있다. 

## 해싱이란 무엇인가?
해싱은 데이터를 빠르게 검색하거나 삽입하기 위해 특정 규칙에 따라 데이터를 변환하는 기술이다. 
데이터를 키(key)와 값(value) 형태로 저장하는 경우, 키를 입력받아 특정 위치를 계산하는 과정을 해싱이라고 한다. 이때 사용되는 함수가 **해시 함수(Hash Function)**이며,  해시테이블의 **키 값으로 레코드가 저장되어 있는 주소(혹은 색인)를 산출하는 함수**이다.
함수의 출력값을 **해시 값(Hash Value)** 또는 **해시 코드(Hash Code)**라고 부른다.

도서관의 책 찾기에 비유해 보자. 
도서관에서 책을 찾으려면 먼저 책이 속한 카테고리(예: 소설, 과학, 역사 등)를 확인하고, 그다음 책이 배치된 선반을 찾는다. 해시 함수는 이 과정에서 책의 카테고리를 결정하고 선반 번호를 알려주는 역할을 한다. 이를 통해 원하는 책에 빠르게 접근할 수 있다.


## HashMap의 구조와 작동 원리
자바의 `HashMap`은 데이터를 **키-값 쌍**으로 저장하며, 내부적으로 **배열**과 **연결 리스트**를 조합하여 구현된다. 이 자료구조는 데이터의 빠른 검색과 삽입을 가능하게 하지만, 구조를 이해하면 그 동작 원리를 더욱 명확히 알 수 있다.

### 데이터 저장의 기본 구조
`HashMap`은 데이터를 저장하기 위해 **배열**을 사용한다. 이 배열의 각 위치를 **버킷(Bucket)** 이라고 부르며, **해시 함수가 반환한 값을 기반으로 데이터가 특정 버킷에 저장**된다. 그러나 서로 다른 키가 같은 버킷에 매핑되는 경우도 있기 때문에, 충돌을 처리할 수 있는 구조가 추가적으로 필요하다.

### 해시 함수의 역할
해시 함수는 입력값(키)을 받아 배열의 인덱스를 반환한다. 간단한 예제로 이를 이해해 보자.
```java
int hash(Object key) {
    return key.hashCode() % arraySize;
}
```
위 코드에서 `hashCode()` 메서드는 객체의 고유한 정수 값을 반환하며, 배열 크기로 나눈 나머지를 통해 배열의 인덱스를 결정한다. 이러한 방식으로 각 키는 특정 버킷에 저장될 위치를 얻게 된다.


## 해시 충돌
해시 충돌은 2가지의 경우에서 발생한다.
1. key는 다른데 hash가 같을 때
2. key, hash 둘 다 다른데 hash % map_capacity 결과가 같을 때

두 개 이상의 키가 동일한 해시 값을 반환할 때 발생한다. 이는 해시 함수가 아무리 잘 설계되더라도 완전히 피할 수는 없다. 자바의 `HashMap`에서는 해시 충돌을 처리하기 위해 **체이닝(Chaining)**과 **오픈 어드레싱(Open Addressing)** 같은 방법을 사용한다.

### 체이닝(Chaining)
체이닝은 충돌된 데이터를 **연결 리스트**로 관리하는 방식이다. 해시 값이 같아 동일한 버킷에 저장되어야 하는 데이터들은 연결 리스트 형태로 이어진다. 아래는 체이닝 구조를 시각적으로 나타낸 표이다.

|인덱스|데이터|
|---|---|
|0|(없음)|
|1|[A -> B -> C]|
|2|(없음)|
예를 들어, 키 `A`, `B`, `C`가 동일한 해시 값을 가졌다면, 이들은 인덱스 1의 연결 리스트로 저장된다. 하지만 연결 리스트를 순차적으로 탐색해야 하므로 충돌이 많아질수록 성능이 저하될 수 있다.


### 개방 주소법(Open Addressing)
오픈 어드레싱은 충돌이 발생했을 때, 데이터를 저장할 **새로운 빈 버킷**을 찾아나서는 방식이다. 연결 리스트를 사용하는 체이닝과 달리, 데이터는 배열 내의 다른 위치에 저장된다. 이 방식에서는 충돌이 많아질수록 빈 공간을 찾는 데 더 많은 시간이 소요될 수 있다.

**선형 탐색(Linear Probing):** 해시충돌 시 다음 버켓, 혹은 몇 개를 건너뛰어 데이터를 삽입한다.

**제곱 탐색(Quadratic Probing):** 해시충돌 충돌 횟수의 제곱만큼 이동하면서 빈 버킷을 탐색한다.(1,4,9,16..)

**이중 해시(Double Hashing):** 해시충돌 시 다른 해시함수를 한 번 더 적용한 결과를 이용함.


### 체이닝 vs 개방 주소법
**◎ 체이닝(Chaining)의 장점**   
 → 연결 리스트만 사용하면 된다. 즉, 복잡한 계산식을 사용할 필요가 개방주소법에 비해 적다.
 → 해시테이블이 채워질수록, Lookup 성능저하가 Linear하게 발생한다. (그림 3 참조)

**◎ 개방주소법(Open Addressing)의 장점**
 → 체이닝처럼 포인터가 필요없고, 지정한 메모리 외 추가적인 저장공간도 필요없다.
 → 삽입,삭제시 오버헤드가 적다.
 → 저장할 데이터가 적을 때 더 유리하다.


## HashMap의 성능
`HashMap`은 해시 함수와 충돌 해결 방식에 따라 성능이 달라진다. 평균적으로 데이터의 검색, 삽입, 삭제 연산은 **O(1)**의 시간 복잡도를 가지지만, 충돌이 많을 경우에는 성능이 저하될 수 있다. 이를 방지하려면 해시 함수가 데이터를 고르게 분포시키도록 설계되어야 한다.

### 좋은 해시 함수의 조건
1. **균등한 분포**: 해시 값이 배열 내의 버킷에 고르게 분포되어야 한다.
2. **빠른 계산**: 해시 값이 효율적으로 계산될 수 있어야 한다.
3. **결정론적 동작**: 동일한 키에 대해 항상 동일한 해시 값을 반환해야 한다.



## 스레드 안전성과 ConcurrentHashMap
기본적으로 `HashMap`은 멀티스레드 환경에서 안전하지 않다. 여러 스레드가 동시에 `HashMap`을 수정하면 데이터 손상이 발생할 수 있다. 
이를 해결하기 위해 동기화된 맵(`Collections.synchronizedMap`) 또는 `ConcurrentHashMap`을 사용할 수 있다.

`ConcurrentHashMap`은 내부적으로 세분화된 락을 사용하여 멀티스레드 환경에서도 안전하게 동작한다.




참고
[해시(Hash)와 해시충돌(Hash Collision)](https://preamtree.tistory.com/20)
