## 커버링 인덱스란?
커버링 인덱스는 쿼리를 충족시키는 데 필요한 모든 데이터를 갖고 있는 인덱스이다.
`SELECT`, `WHERE`, `ORDER BY`, `GROUP BY` 등에 사용되는 모든 컬럼이 인덱스의 구성요소일 때를 말한다.

커버링 인덱스가 적용되면 실행계획의 extra 필드에 `Using Index`가 표시된다고 한다.

### index가 표시되는 다른 항목들

| 표기    | 설명                    |                                                     |
| ----- | --------------------- | --------------------------------------------------- |
| Extra | Using index           | 커버링 인덱스 (쿼리의 모든 항목이 인덱스 컬럼으로 이루어진 상태)               |
| Extra | Using index condition | [인덱스 컨디션 푸시다운 인덱스](https://jojoldu.tistory.com/474) |
| type  | index                 | 인덱스 풀 스캔 (range 스캔이 아님)                             |

## Non Clustered Key와 Clustered Key
|                   | 대상                                                                            | 제한             |
| ----------------- | ----------------------------------------------------------------------------- | -------------- |
| Clustered Key     | 1) PK  <br>2) PK가 없을땐 유니크키  <br>3) 1~2 둘다 없을 경우 6byte의 Hidden Key를 생성 (rowid) | 테이블당 1개만 존재 가능 |
| Non Clustered Key | 일반적인 인덱스                                                                      | 여러개 생성 가능      |

**Non Clustered Key와 Clustered Key 탐색**
![[커버링 인덱스-20240417160026616.webp]]

- Non Clustered Key(일반적인 인덱스)는 인덱스 컬럼의 값들과 Clustered Key(PK)의 값이 포함되어 있다. (사진에서 A, B, C, D...를 말하는 듯 하다)
- Clustered Key는 실제 테이블의 row 위치를 알고 있다.(21, 17, 19...)

즉 `where`조건이 인덱스 탐색 조건에 부합하더라도 `select`문에 인덱스에 포함된 컬럼 외에 다른 컬럼값이 있다면 Non Clustered Key에 있는 Clustered Key 값으로 데이터 블록을 찾는 과정이 필요하다.
**다만 PK를 사용할 경우 인덱스 탐색 시간이 없어지기 때문에 향상된 데이터 파일 접근이 가능하다**

> [!NOTE] 커버링 인덱스는 여기서 "2. 실제 데이터 접근" 의 행위 없이 인덱스에 있는 컬럼값들로만 쿼리를 완성하는 것을 말한다.

## 예시1 - SELECT
temp_ad_offset이라는 테이블이 있다고 가정함

인덱스에 customer_id 컬럼만 존재할 경우 아래 쿼리의 [[실행 계획]]은 아래와 같다.
```sql
select *
from temp_ad_offset
where customer_id = 7;
```
![[커버링 인덱스-20240417162005241.webp|400]]
key를 보면 인덱스가 잘 사용되었지만 select절의 필드를 완성하기 위해 데이터 블록 접근이 있었다를 의미한다.

그럼 select 절에 customer_id라고 명시하면 어떻게 될까
```sql
select customer_id
from temp_ad_offset
where customer_id = 7;
```
![[커버링 인덱스-20240417162430879.webp|400]]
extra 항목에 Using index가 등장했다.
이 쿼리는 **인덱스에 포함된 컬럼**(customer_id)**만으로 조회가 가능**하니 **커버링 인덱스**가 사용된 것이다!

> [!CAUTION] Extra 항목에 `Using index`가 있어야만 인덱스를 사용한 것인가?
> 인덱스 사용 유무는 **key 항목에 선택된 인덱스**가 있냐 없냐의 차이다.
> Extra 항목에 `Using index`가 있는 경우는 **쿼리 전체가 인덱스 컬럼값으로 다 채워진 경우**에만 발생한다.

## 예시2 - WHERE + GROUP BY
참고 -  [[GROUP BY절 인덱스#인덱스 적용 조건]]

`WHERE`절과 `GROUP BY`절이 함께 사용되면 인덱스는 어떻게 적용될까?
`WHERE` 조건이 동등 비교일 경우 `GROUP BY`절에 인덱스 컬럼이 없어도 적용된된다.

아래 2 쿼리는 정상적으로 인덱스가 적용됨
ex) 인덱스 - a,b,c
```sql
WHERE a = 1 
GROUP BY b, c

WHERE a = 1 and b = 'b'
GROUP BY c
```

### WHERE문이 동등 비교일 때

(인덱스 - offset_type, customer_id, base_date)

- **where 조건이 동등 비교일 때 실행 계획**
```sql
select *
from temp_ad_offset
where offset_type = 'GIVE_OFFSET'
group by customer_id, base_date
limit 2000000, 100;
```
![[커버링 인덱스-20240417164011756.webp|400]]
key를 보면 인덱스가 잘 타졌고 extra 항목에 `Using temporary` 와 `Using filesort`가 없는데
이는 **GROUP BY가 인덱스를 잘 탔다** 정도로 보면 된다(이후에 다시 설명)
수행시간은 5.6초

- **where을 like로 바꾸면?**
(%를 앞에 두면 인덱스를 타지 않으니 뒤에 두도록 하자.)
```sql
select *
from temp_ad_offset
where offset_type like 'GIVE%'
group by customer_id, base_date
limit 2000000, 100;
```
![[커버링 인덱스-20240417173006846.webp]]
key를 보면 여전히 인덱스가 잘 타졌다. 
근데 extra에 위에서 말했던 `Using temporary` 와 `Using filesort`가 등장했다. 
이는 별도의 임시 테이블(temporary)를 만들어 그 안에서 정렬(filesort)했다는 뜻이다.
인덱스 key대로 GROUP BY가 됐다면 인덱스 key대로 그룹핑만 하면 되기 때문에 별도의 임시테이블을 만들지 않아도 된다.  GROUP BY가 제대로 인덱스를 타지 못한 것 같다.
수행시간은 1분이다. 확연하게 느려졌다.

### 커버링 인덱스 적용해보기
WHERE-GROUP BY가 인덱스를 탄 상황에서 SELECT 까지 인덱스를 타도록 해보자
select절에 인덱스 컬럼을 전부 조회해보자.
```sql
select offset_type, customer_id, base_date
from temp_ad_offset
where offset_type = 'GIVE_OFFSET'
group by customer_id, base_date
limit 2000000, 100;
```
![[커버링 인덱스-20240417173716697.webp]]
수행 시간은 1.6초로 5.6초 대비 5배 이상 개선되었다.

## 예시3 - WHERE + ORDER BY
참고 - [[ORDER BY절 인덱스#인덱스 적용 조건]]

 
## 참고
[1. 커버링 인덱스 (기본 지식 / WHERE / GROUP BY)](https://jojoldu.tistory.com/476)