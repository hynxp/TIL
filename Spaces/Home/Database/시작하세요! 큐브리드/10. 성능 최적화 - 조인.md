## 조인
일반적으로 DBMS에서 사용하는 조인 연산의 종류에는 내부 조인, 외부 조인, 교차 조인 등이 있다.

### 조인 연산의 종류
![[IMG-20250716042928236.png|500]]

조인 연산의 종류로는 이 밖에 완전 외부 조인(full outer join)이 있는데 큐브리드는 이를 지원하지 않는다

### 조인과 집합 연산

![[IMG-20250716043008392.png]]

UNION ALL은 UNION과 달리 중복을 제거하지 않아 새로 만든 집합을 정렬하지 않으므로 질의 성능에 차이가 생길 수 있다. 질의 결과 집합이 이미 중복이 제거된 집합이라면 UNION ALL을 사용하는 것이 더 효율적이다

### 조인 방법
#### 1. 중첩된 루프 조인
중첩된 루프 조인은 **좁은 범위의 데이터를 빠르게 추출**해야 하는 경우에 효과적인 조인 방식이다.  
부분 범위 처리(partial range scan)가 가능하기 때문에, 조인 조건을 만족하는 결과가 존재한다면 먼저 찾아낸 레코드를 바로 사용자에게 반환할 수 있다.  
이처럼 **사용자 응답을 빠르게 제공해야 하는 상황**에서 유리하다.

> **💡 반면, 처리 범위가 넓은 대량 데이터 조인에는 부적합하며, 이 경우에는 정렬 병합 조인(Sort Merge Join)이나 해시 조인(Hash Join)이 더 적합하다.**

조인 수행 시 테이블은 `선행 테이블(outer table)`과 `후행 테이블(inner table)`로 나뉘며, 중첩된 루프 조인에서는  
선행 테이블을 한 행씩 순차적으로 탐색하고, 각 행마다 후행 테이블에서 조인 조건을 만족하는 레코드를 찾아 결합한다.

- 선행 테이블: 먼저 순회하면서 조인 조건을 준비하는 테이블
- 후행 테이블: 선행 테이블의 각 행마다 조건을 만족하는 데이터를 찾아야 하는 테이블

> **💡 후행 테이블의 조인 칼럼에는 반드시 인덱스가 존재해야 한다.**

인덱스가 없을 경우, 후행 테이블 전체를 스캔하며 비교해야 하므로  
**선행 테이블의 건수 × 후행 테이블의 전체 건수**만큼의 비교가 발생하게 되고, 이는 심각한 성능 저하를 유발한다.

다음 그림에 중첩된 루프 조인의 처리 절차를 표현했다. 왼쪽 테이블이 선행 테이블이고 오른쪽 테이블이 후행 테이블이다. 선행 테이블에서 데이터를 탐색한 후 조건에 만족하는 데이터에 대해 후행 테이블 칼럼 의 인덱스를 탐색한 후 데이터를 추출한다.

![[IMG-20250716043050809.png]]

① 선행 테이블(tab1)의 탐색
- `a.col1 = 'AB'` 조건에 따라 인덱스(col1)를 탐색한다.
- 탐색 결과, 인덱스에서 OID(Object Identifier)를 획득하고, 해당 OID를 이용해 테이블에서 실제 데이터를 읽는다.
- WHERE 조건으로 지정된 필터(a.key1 = …)를 적용하여 만족하는 데이터만 후행 테이블 탐색 대상으로 삼는다.

② 후행 테이블(tab2)의 탐색
- 선행 테이블에서 가져온 값(`a.key1`)을 바탕으로 후행 테이블의 인덱스(KEY1)를 탐색한다.
- b.col2 = 10 조건도 같이 적용한다.
- 탐색된 인덱스 노드에서 다시 OID를 통해 테이블 페이지에 접근해 데이터를 읽는다.
- 조건을 만족하는 레코드는 최종 조인 결과에 포함된다.

**🤔 왜 랜덤 I/O가 많이 발생할까?**
중첩된 루프 조인은 선행 테이블의 각 행마다 후행 테이블을 반복적으로 스캔한다.  
이 과정에서 **후행 테이블의 인덱스를 매번 탐색하고, 다시 데이터 페이지에 접근**하기 때문에 디스크 상에서 **비순차적인 랜덤 I/O**가 발생한다.

> **💡 후행 테이블의 조인 칼럼에 인덱스가 없으면, 후행 테이블 전체를 선행 테이블 건수만큼 반복 스캔해야 하므로 성능이 급격히 저하된다.**


#### 정렬 병합 조인
정렬 병합 조인은 주로 **OLAP(Online Analytical Processing)**, 즉 일괄 처리 중심의 대용량 질의 환경에서 성능을 확보하기 위해 사용되는 조인 방식이다. OLTP처럼 빠른 응답을 중시하는 환경보다는, 비교적 **넓은 범위의 데이터를 일괄적으로 처리**해야 하는 상황에 적합하다.

정렬 병합 조인은 조인 대상 테이블들을 먼저 각각 **검색 조건에 따라 필터링**한 후, **조인 키를 기준으로 정렬**하고, 이후 **병합(Merge)** 하는 방식으로 조인을 수행한다.

![[IMG-20250716043112216.png]]
① 각 테이블 조건 필터링
- `tab1`에서 `a.col1 = 'AB'` 조건으로 필터링
- `tab2`에서 `b.col2 = 10` 조건으로 필터링
- 이때 인덱스가 존재하면 `INDEX(col1)`, `INDEX(col2)` 등을 통해 **OID를 추출**하고 빠르게 데이터 접근

② WHERE 조건을 만족하는 데이터 추출
- OID를 기반으로 실제 테이블의 데이터를 읽는다
- 이후 `a.key1 = b.key2` 조인 조건에 해당하는 값만 남긴다

③ 각각 정렬(SORT)
- 두 테이블의 조인 키(`a.key1`, `b.key2`) 기준으로 정렬
- 이 작업은 메모리에서 처리되지만, 메모리가 부족할 경우 디스크 임시 공간을 사용하기 때문에 **디스크 I/O 발생 가능성**이 있다

④ 정렬된 두 집합 병합 (MERGE)
- 정렬된 두 테이블의 조인 키를 서로 비교하면서 병합
- 조인 대상이 되는 키가 동일한 경우, 해당 레코드들을 결과 집합에 포함시킨다

중첩된 루프 조인에서는 선행 테이블과 후행 테이블 개념이 있고 선행 테이블의 범위가 충분히 좁혀져야 질의 성능이 향상된다. 반면 정렬 병합 조인에서는 조인에 사용되는 두 테이블 사이에는 순서가 없으며, 각 테이블의 탐색 범위가 좁으면 당연히 성능은 높아지겠지만 두 테이블 중 어느 쪽이 범위가 넓고 좁은가는 성능에 있어서 고려 사항이 아니다. 

 정렬 병합 조인 방식에서는 각 테이블의 데이터를 추출해 각각 정렬한 후 병합한다.
 이 과정에서 데이터를 추출한다는 것은 메모리에서 작업하는 것을 의미하며, 메모리가 부족할 경우 당 연히 임시 볼륨과 같은 디스크에 저장되므로 디스크 I/O가 발생할 수 있다

조인에 사용되는 양쪽 테이블을 모두 정렬한 후 병합하는 과정에서는 두 조인 조건의 칼럼값을 비교해가면서 데이터를 만든다. 
이렇게 조인에 필요한 데이터를 모두 추출한 후 조인을 시도하기 때문에 조인 연결 고리에 사용되는 칼럼 사이의 처리 성능보다는 각 테이블의 검색 조건으로 추출한 데이터의 양에 비례해서 성능 차이가 발생한다. 두 테이 블의 데이터를 우선 추출한 후 조인하므로 중첩된 루프 조인과 달리 부분 범위를 처리하지 못한다
