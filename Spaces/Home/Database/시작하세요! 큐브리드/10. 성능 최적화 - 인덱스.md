## 인덱스(Indexes)
큐브리드는 B+트리 구조의 인덱스를 사용한다. 중간 노드(non‑leaf node)는 키만, 리프 노드(leaf node)는 실제 데이터 또는 데이터 주소를 저장한다.

> **💡 키 값 정렬에 따른 노드 구조**: 영리한 트리 구성 덕분에 검색 조건이 일치하지 않으면 탐색을 바로 중단할 수 있다. 이는 곧 범위 검색 성능이 빨라진다는 뜻이다.

### 클러스터형 vs 비클러스터형
- **클러스터형 인덱스**: 인덱스 키와 데이터가 함께 저장되고, 인덱스 순서가 데이터 순서가 된다. 테이블당 하나만 생성 가능.
- **비클러스터형 인덱스**: 인덱스 키와 함께 데이터의 주소(OID)만 저장. 데이터는 별도의 저장 공간인 힙(heap)에 저장된다. 조회 시 OID를 통해 데이터 페이지에 접근한다.


**큐브리드는 비클러스 터형 인덱스만 지원**하며 데이터 주소는 OID(object identifier)라는 형식으로 저장한다.
클러스터형 인덱스가 없는 테이블을 힙 구조의 테이블이라고 한다

힙 테이블 구조에서는 인덱스와 데이터 저장 순서가 다를 수 있으며, 범위가 클 경우 랜덤 액세스가 많이 발생해 성능 저하가 생기니 주의해야 한다.

#### 인덱스 구조 내 최적화 기능
- **인덱스 범위 스캔 (Index Range Scan)**: 예: `WHERE age BETWEEN 21 AND 24`
    - 이 경우 연속적인 키 범위만 탐색하기 때문에 특정 범위의 데이터만 빠르게 검색할 수 있다.
    - 💡 범위가 넓다면 테이블 전체 스캔보다 효율이 떨어질 수 있으니 범위 크기에 따라 인덱스 사용 여부를 고심해야 한다.

#### 예시
예를 들어, 다음과 같은 질의를 실행한다고 가정하자.
```sql
SELECT * FROM tbl WHERE age BETWEEN 21 AND 24;
```
이 질의를 실행할 때 인덱스 범위 스캔은 다음과 같이 동작한다.
![[IMG-20250716042104386.png]]

인덱스 범위 스캔을 사용하면 특정 범위를 검색하기 위해 테이블 전체 스캔(table full scan)을 하지 않고도 신속하게 데이터를 가져올 수 있다.
하지만 데이터 범위가 크다면 다량의 랜덤 액세스로 성능이 떨어질 수 있으므로 데이터 범위에 따라 인덱스를 사용할 것인지를 미리 생각해봐야 한다. 


### 질의 처리 과정
CUBRID에서는 질의를 처리할 때 **질의 실행 계획**을 기반으로 아래와 같은 순서를 따라 수행된다:

> **💡 키 범위(key range) → 키 필터(key filter) → 데이터 필터(data filter) → 정렬** 의 네 단계로 진행되며, 이 과정을 거쳐 최종적으로 결과 데이터가 반환된다.

아래 예제를 통해 각 단계가 어떻게 작동하는지 살펴보자.
```sql
SELECT * FROM tbl 
WHERE a > 1 AND a < 5 
  AND b < 'K' 
  AND c LIKE '123456%';
```
✔️ 이 쿼리는 인덱스가 `(a, b)`로 구성된 상태에서 실행된다고 가정한다.

1. CUBRID는 먼저 `a > 1 AND a < 5` 조건을 기반으로 인덱스의 **키 범위**를 설정하고 해당 범위에 있는 인덱스 노드를 순차적으로 스캔
2.  `b < 'K'` 조건에 따라 **키 필터**를 적용한다.  
3. 키 필터 조건을 만족하는 노드로부터 OID(데이터의 위치 정보)를 수집하여 **OID 버퍼**에 저장
4.  `c LIKE '123456%'` 조건을 확인하기 위해 OID에 해당하는 실제 데이터 페이지에 접근한다.  
5. 마지막으로 SELECT 절에 지정된 컬럼 값들을 추출해 결과로 반환한다.

이제 이 과정을 하나씩 단계별로 자세히 살펴보자.

![[IMG-20250716042155151.png]]

#### 키 범위
**키 범위**는 인덱스를 통해 스캔할 범위를 의미하며, 인덱스에서의 실제 스캔 시작점과 종료점을 지정하는 조건이다. 위 예제에서는 `a > 1 AND a < 5`이 키 범위에 해당한다

즉, 인덱스에서 `a` 컬럼이 1보다 크고 5보다 작은 구간에 해당하는 노드를 스캔하게 된다. 이 범위는 인덱스 트리의 리프 노드들 중 일부분에 해당하며, 해당 범위 안의 모든 키들을 탐색한다.

> **💡 키 범위는 질의의 전체 성능에 가장 큰 영향을 준다.**  
> 이후 단계인 키 필터, 데이터 필터 과정에서 처리해야 할 데이터의 양이 결정되기 때문이다.

키 범위의 시작부터 끝까지 스캔하며 OID를 수집하고, 여기서 수집한 OID는 OID 버퍼에 보관했다가 뒤의 데이터 필터 단계에서 꺼내 쓴다.

#### 키 필터
**키 필터**는 인덱스의 키 범위에는 포함되지 않지만, 인덱스로 처리 가능한 조건이 키 필터로 처리된다. 
여기서는 `b < 'K'`가 키 필터 에 해당한다. 

이 조건은 인덱스의 두 번째 컬럼인 `b`에 대한 조건이지만, 키 범위를 지정한 `a`와는 다르므로 **두 번째 칼럼 필터**로 작동한다. 이 경우, 키 범위에 포함된 모든 리프 노드에 대해 `b < 'K'` 조건을 추가로 검사하여 해당하는 OID만 남긴다.

> **💡 키 필터는 키 범위보다 연산 비용이 더 크며, 필터링 대상 레코드 수가 많을 경우 성능에 악영향을 줄 수 있다.**  
> 따라서 키 범위로 최대한 좁히고, 키 필터 조건은 가볍게 유지하는 것이 좋다.

질의 실행 계획에는 다음과 같이 출력된다.

![[IMG-20250716042514047.png]]
이 질의 실행 계획에서 term[2]가 키 범위, term[0]이 키 필터, term[1]이 데이터 필터임을 알 수 있다.

#### 데이터 필터
**데이터 필터**는 인덱스 키에 포함되지 않은 칼럼에 대한 조건으로, OID를 통해 실제 데이터 페이지에 접근해야만 적용할 수 있는 조건이다.
여기서는 `c LIKE '123456%`가 데이터 필터에 해당한다. 

키 범위와 키 필터를 통해 수집한 OID 버퍼에 저장된 OID를 하나씩 데이터 페이지에서 랜덤 액세스해 레 코드 위치를 찾은 후, 해당 칼럼의 값이 유효한지 데이터 필터를 통해 확인해 유효한 값을 임시 페이지에 저장한다.

> **💡 데이터 필터는 결국 데이터 페이지를 랜덤하게 접근해야 하므로 비용이 가장 크다.**  
> 키 필터보다도 더 많은 디스크 I/O가 발생할 수 있으므로 가급적 인덱스에 포함시키거나 조건 자체를 줄이는 것이 좋다.

#### 성능 최적화 요령
질의 튜닝 시 다음과 같은 우선순위를 고려하는 것이 좋다.

> **💡 성능 영향도 순서: 키 범위 > 키 필터 > 데이터 필터**

- **키 범위** 조건은 인덱스 스캔 범위를 제한하므로 가장 중요하다.
- **키 필터**는 리프 노드를 순회하면서 추가 조건을 확인해야 하므로 성능에 부담이 될 수 있다.
- **데이터 필터**는 결국 테이블 랜덤 접근을 발생시키기 때문에 **가능하면 인덱스에 포함**되도록 리팩토링하는 것이 바람직하다.

즉, 질의 성능을 향상시키기 위한 가장 기본적인 방법은 **키 범위로 가능한 많은 조건을 포함하고, 키 필터나 데이터 필터 조건을 인덱스로 끌어올리는 것**이다.


### 커버링 인덱스
**커버링 인덱스**란 SELECT 문에 사용된 **모든 칼럼**이 인덱스에 포함되어 있어, **데이터 페이지에 접근하지 않고도 질의를 처리할 수 있는** 인덱스 최적화 기법이다.  
WHERE 절, GROUP BY, ORDER BY, SELECT 리스트에 등장하는 칼럼들이 모두 인덱스 내에 존재하면 커버링 인덱스가 적용된다.

> **💡 커버링 인덱스가 적용되면 디스크 I/O가 크게 줄고, 결과를 추출하는 데 걸리는 시간이 현저히 감소한다.**

실행 계획 상에서는 `(covers)` 키워드가 나타나며, 이는 **인덱스만으로 질의가 처리되었음**을 의미한다.

#### 예제
인덱스가 `(a, b)`로 구성되어 있다고 가정할 때, 다음과 같은 질의는 커버링 인덱스를 활용할 수 있다

```sql
SELECT a, b 
FROM tbl 
WHERE a > 1 AND a < 5 AND b < 'K' 
ORDER BY b;
```
![[IMG-20250716042550298.png]]
왼쪽의 **인덱스 단말(leaf) 페이지**는 정렬된 상태로 키값과 OID를 함께 저장하고 있다.  
조건에 부합하는 인덱스 항목들은 **키 버퍼**에 담기고, 이후 필요한 정렬을 거친 뒤 최종 결과로 추출된다.

> **💡 “만족하는 데이터가 인덱스 단말 노드에 모두 존재하므로 데이터 페이지로 접근은 발생하지 않음”**  이 구조 덕분에 랜덤 액세스 없이 빠르게 결과를 가져올 수 있다.

#### PostgreSQL 및 MySQL과의 차이점

|항목|CUBRID|PostgreSQL|MySQL (InnoDB)|
|---|---|---|---|
|커버링 인덱스|`(covers)`로 명시적 표시|`Index Only Scan`으로 처리 (조건: visibility 확인 필요)|실행 계획에 `Using index`로 표시|
|동작 방식|OID만으로 확인, 별도 테이블 접근 없음|MVCC로 인해 힙 접근이 필요할 수 있음|인덱스가 실제 데이터를 포함함 (클러스터형)|
- PostgreSQL은 커버링 인덱스를 **"Index Only Scan"** 이라는 개념으로 지원하지만, MVCC 특성 때문에 힙 접근을 피할 수 없는 경우가 있다.
- MySQL(InnoDB)은 클러스터형 인덱스 구조이기 때문에, 기본적으로 PK에 의한 커버링 인덱스 효과가 있다.

### 정렬 작업 생략
**정렬 작업 생략**이란 `ORDER BY` 절에 명시된 정렬 대상 칼럼의 순서가 **인덱스 컬럼의 순서와 동일할 경우**,  
추가적인 정렬 작업을 하지 않고 인덱스에 정렬된 상태 그대로 결과를 반환하는 기법이다.

> **💡 이 기법이 적용되면 `ORDER BY` 수행을 위한 정렬 비용이 발생하지 않으므로 성능이 크게 향상된다.**

CUBRID에서는 이 기법이 적용될 경우 **질의 실행 계획에서 `(skip order by)`** 라는 문구로 확인할 수 있다.

`(a, b)`로 구성된 인덱스가 있을 경우 정렬 작업 생략 여부에 따른 동작 방식의 차이를 살펴보자.

#### 1. 정렬 작업이 생략되지 않는 경우
```sql
SELECT * 
FROM tbl 
WHERE a = 2 AND b < 'K' 
ORDER BY c;
```
이 경우 인덱스는 `(a, b)`로 구성되어 있으나, 정렬 대상인 `c` 칼럼은 인덱스에 포함되지 않거나, 순서가 다르다.
따라서 인덱스에서 조건에 맞는 OID를 수집한 후, 실제 데이터 페이지에 접근하여 `c` 값을 추출하고,  
그 값을 기준으로 **추가적인 정렬 작업을 한 번 더 수행**해야 한다.

![[IMG-20250716042623302.png]]
- 인덱스 단말 노드에서 `OID5`, `OID9`, `OID13`을 수집하고
- 해당 OID에 해당하는 **테이블 힙 페이지**에서 레코드를 찾는다
- 레코드의 `c` 칼럼 값을 기준으로 **정렬 작업을 추가로 수행**한다

#### 2. 정렬 작업이 생략되는 경우
```sql
SELECT * 
FROM tbl 
WHERE a = 2 AND b < 'K' 
ORDER BY b;
```
이 경우 인덱스 칼럼 순서가 칼럼 정렬 순서와 같기 때문에 별도의 정렬 작업이 생략된다.
따라서 인덱스 자체가 이미 `b` 컬럼 순으로 정렬되어 있으므로,  
추가 정렬 없이 인덱스 순회만으로 결과를 정렬된 상태로 바로 반환할 수 있다.

![[IMG-20250716042643908.png]]
- 인덱스에서 조건에 맞는 OID를 수집
- 해당 레코드를 힙에서 읽어와 결과 집합 생성
- **별도의 정렬 작업 없이 결과 바로 반환**


### 그룹화 작업 생략
**그룹화 작업 생략**이란, `GROUP BY` 절에서 사용하는 컬럼의 정렬 순서가 인덱스 컬럼 순서와 동일할 경우  
별도의 정렬 작업 없이 인덱스 자체의 정렬 정보를 그대로 활용해 그룹화 결과를 생성하는 기법이다.

> **💡 인덱스의 정렬 순서를 그대로 따라가며, 같은 그룹이 연속적으로 붙어 있기 때문에 정렬 없이 한 번씩만 값 추출이 가능하다.**

이 기법이 적용되면 질의 실행 계획에 `(skip group by)`가 나타난다.

#### 예제
```sql
SELECT COUNT(*) 
FROM tbl 
WHERE a > 1 AND a < 5 AND b < 'K' AND c > 10000 
GROUP BY a;
```
위 쿼리에서 인덱스가 `(a, b)`로 되어 있는 경우, `GROUP BY a`는 인덱스의 첫 번째 컬럼과 일치하므로  
정렬 없이도 그룹핑이 가능하다.

![[IMG-20250716042709420.png]]
- 인덱스 단말 노드를 따라 OID를 수집하고
- OID에 해당하는 레코드를 테이블 힙 페이지에서 조회한 후
- **정렬 없이 그룹 기준이 되는 `a` 값이 바뀔 때마다 집계 처리를 수행**


### 내림차순 인덱스 스캔
내림차순 인덱스 스캔은 인덱스의 기본 정렬 순서가 오름차순(ASC)이지만, 쿼리에서 `ORDER BY ... DESC` 조건이 주어졌을 때
인덱스의 뒤에서부터 앞으로 스캔하는 방식으로 결과를 효율적으로 가져오는 최적화 기법이다.

> 💡 **별도의 정렬 작업 없이 역순으로 인덱스를 탐색하여 결과를 반환**할 수 있다.

실행 계획에는 `(desc_index)` 키워드로 표시된다.

#### 예제
```sql
SELECT * 
FROM tbl 
WHERE a = 2 AND b < 'K' 
ORDER BY b DESC;
```
인덱스가 `(a ASC, b ASC)`로 구성되어 있어도, `ORDER BY b DESC` 조건이 주어지면  
a=2 범위 내에서 b 컬럼 값을 **역순으로 정렬된 결과를 인덱스 뒤에서부터 스캔**하여 가져온다.

![[IMG-20250716042726913.png]]
- 인덱스 단말 노드에서 `a=2`인 값들을 **뒤에서부터 읽는다**
- 그 결과 `OID13`, `OID9`, `OID5` 순으로 수집된다
- 이후 해당 레코드를 읽어와 결과를 반환하며 **별도의 정렬 작업이 발생하지 않는다**

### NULL 처리
CUBRID에서는 **NULL 값을 인덱스에 포함하지 않는다.**
즉, 인덱스는 `NULL` 값을 건너뛰며, 단지 **인덱스 통계 정보에서 NULL 개수만 별도로 관리**한다.

> 💡 그 결과, `IS NULL`, `IS NOT NULL` 조건에서는 인덱스를 사용할 수 없다.

#### 우회법
하지만 아래와 같은 방식으로 **NULL을 우회적으로 인덱스로 활용할 수 있다.**

|자료형|NULL 회피 조건 예시|
|---|---|
|문자형|`WHERE col > ''`|
|숫자형|`WHERE col > -2147483648` (INT 기준 최솟값)|
> **💡 WHERE 조건을 NULL 대신 극단적인 값 비교로 바꾸면 옵티마이저가 인덱스를 활용할 수 있다.**

### 인덱스 최적화
CUBRID에서 인덱스를 설계하거나 튜닝할 때는 단순히 자주 조회되는 칼럼에만 인덱스를 생성하는 것이 아니라, 다양한 요소를 함께 고려해야 한다.
다음은 인덱스 최적화 시 반드시 고려해야 할 핵심 사항들이다.

#### 1. 데이터 분포 고려
인덱스를 생성할 칼럼의 **데이터 분포가 고르지 않으면 성능에 불리**하게 작용할 수 있다.  
예를 들어 ‘남/여’처럼 중복 값이 많은 칼럼에 인덱스를 생성하면, **선택도(selectivity)**가 낮아져 인덱스를 사용해도 필터링 효과가 떨어지며,  
삭제나 갱신 연산 시 **동일한 인덱스 노드에 집중되어 성능 저하**가 발생할 수 있다.

> 💡 데이터 분포가 치우친 경우, 더미 칼럼을 함께 조합한 복합 인덱스를 구성하여 인위적으로 분포를 분산시키는 방법이 있다.

```sql
-- 예시: 성별만으로는 분포가 불균형
CREATE INDEX idx_gender ON member(gender);

-- 개선: 나이대와 조합하여 분포 개선
CREATE INDEX idx_gender_age ON member(gender, age_group);
```

#### 2. 실행 계획 영향 분석
인덱스를 하나만 추가해도 **기존 질의 전체의 실행 계획이 바뀔 수 있다.**  
CUBRID 옵티마이저는 가능한 인덱스 후보를 모두 고려하여 최적의 실행 경로를 선택하므로,  
새로운 인덱스가 추가되면 **기존 쿼리들도 예상과 다른 인덱스를 타게 될 수 있다.**

> 💡 반드시 `EXPLAIN`을 통해 기존 질의들의 실행 계획을 재점검하고, 새 인덱스가 실제로 성능에 도움이 되는지 검토해야 한다.

#### 3. 인덱스 수 최소화
인덱스는 SELECT 성능을 향상시키는 반면, INSERT/UPDATE/DELETE 같은 **DML 연산에는 추가 비용이 발생**한다.  
데이터를 수정할 때마다 해당 인덱스를 갱신해야 하므로, 인덱스가 많을수록 DML 성능은 저하된다.

> **💡 실제로 사용되지 않는 인덱스는 과감히 제거하고, 꼭 필요한 인덱스만 유지해야 한다.**

```sql
-- 자주 사용되지 않는 인덱스 확인
SHOW INDEX FROM tbl WHERE Cardinality < 특정 기준;
```

#### 4. 커버링 인덱스 구성
**커버링 인덱스**는 인덱스만으로 SELECT 쿼리를 처리할 수 있으므로 **데이터 페이지 접근이 불필요하고 랜덤 액세스가 줄어들어** 성능이 매우 뛰어나다.

> 💡 커버링 인덱스를 설계할 때는 WHERE, SELECT, GROUP BY, ORDER BY에 사용되는 모든 칼럼이 인덱스에 포함되도록 구성한다.

단, 인덱스에 대한 갱신 비용을 감안해 인덱스를 구성하는 전체 칼럼의 크기가 너무 커지지 않도록 유의한다. 

#### 5️. 정렬 가능 인덱스 설계
인덱스의 정렬 순서를 활용하면 `ORDER BY`, `GROUP BY` 절을 사용할 때 **정렬 작업을 생략(skip)**할 수 있어 성능을 향상시킬 수 있다.

- `ORDER BY` 칼럼이 인덱스 칼럼 순서와 일치 → `(skip order by)`
- `GROUP BY` 칼럼이 인덱스와 정렬 순서 일치 → `(skip group by)`

이러한 최적화는 정렬 비용이 높은 대량 데이터 처리에서 매우 큰 차이를 만들 수 있다.
