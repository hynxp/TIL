트랜잭션이 동시에 여러 개 수행될 수 있게 하는 성질을 동시성이라 한다. 동시성이 높다는 것은 동시에 처리할 수 있는 트랜잭션의 수가 많다는 의미다

트랜잭션이 동시에 여러 개 수행되는 환경에서 일 관성을 보장하려면 리소스를 공유하지 않는 연산은 동시에 수행을 허용하고, 연산이 리소스를 공유한다면 해당 리소스를 먼저 획득한 트랜잭션이 먼저 사용하게 하는 등의 관리가 필요하다. 이를 트랜잭션의 동시 성 제어(concurrency control)라 한다

트랜잭션은 읽기 일관성을 높이면 동시성이 낮아지고 읽기 일관성을 낮추면 동시성이 높아지는 특성이 있 다.

## 트랜잭션과 처리
### 트랜잭션 관리
큐브리드는 동시에 수행되는 트랜잭션 사이에서 공유되는 리소스를 **잠금(lock)** 으로 관리한다.  

예를 들어 트랜잭션 `Tx1`이 갱신 중인 데이터에 `Tx2`가 접근해야 하는 경우, 큐브리드는 `Tx1`에게 잠금을 제공하고, `Tx2`는 `Tx1`이 사용을 종료할 때까지 대기하도록 한다.

- `Tx1`: **잠금 보유자(lock holder)**
- `Tx2`: **잠금 대기자(lock waiter)**

여러 개의 트랜잭션이 서로 상대방이 사용 중인 데이터를 갱신하기를 기다리는 상황이 발생하면, 더 이상 어떤 트랜잭션도 작업을 진행할 수 없는 **교착 상태(deadlock)**가 된다.

큐브리드는 이러한 교착 상태를 **자동으로 감지**하고, 트랜잭션 중 **하나를 롤백**시켜 교착 상태를 해소한다. 일반적으로는 **가장 적은 행을 갱신한 트랜잭션**을 롤백 대상으로 삼는데, 이는 **가장 최근에 시작된 트랜잭션**이 그럴 가능성이 크므로 해당 트랜잭션이 선택된다.

잠금 대기 시간 제한(`lock timeout`)을 설정하면 잠금 대기가 무한히 지속되는 상황을 방지할 수 있다.  
잠금 대기 시간이 너무 길어지면 해당 트랜잭션이 보유한 잠금으로 인해 다른 트랜잭션이 계속 대기하게 된다.  
`lock_timeout`은 `cubrid.conf` 파일에서 설정하며, 기본값은 **무제한**이다.

교착 상태 발생을 줄이려면 다음과 같은 방법이 있다

- 트랜잭션 수행 시간을 짧게 유지한다.
- 인덱스를 적절히 설정해 잠금이 설정되는 범위를 최소화한다.
- 트랜잭션 격리 수준(isolation level)을 낮게 설정한다.


## 트랜잭션 격리 수준
트랜잭션 격리 수준은 **동시에 수행 중인 트랜잭션 사이에서 읽기 일관성을 어느 정도까지 보장할 것인지**를 명시하는 기준이다.

- **격리 수준이 높을수록**: 읽기 일관성이 보장되지만 **동시성은 낮아진다.**
- **격리 수준이 낮을수록**: 동시성이 높아지지만 읽기 일관성이 약해진다.

운영 환경에 따라 어떤 수준의 일관성과 동시성이 필요한지 고려해 설정해야 한다.

![[IMG-20250705001407945.png|500]]

### 읽기 일관성과 관련된 문제
| 현상                                   | 설명                                                          |
| ------------------------------------ | ----------------------------------------------------------- |
| **더티 읽기 (dirty read)**               | 아직 커밋되지 않은 트랜잭션(Tx1)이 쓴 데이터를 Tx2가 읽는 것                      |
| **반복 불가능한 읽기 (non-repeatable read)** | Tx1이 데이터를 읽은 후, Tx2가 해당 데이터를 갱신/삭제하여 Tx1이 다시 읽을 때 값이 달라지는 것 |
| **유령 읽기 (phantom read)**             | Tx1이 특정 범위의 레코드를 반복 조회 중, Tx2가 새로운 레코드를 삽입하여 조회 결과가 달라지는 것  |

큐브리드가 지원하는 트랜잭션 격리 수준은 총 **6단계**지만, 대부분의 시스템에서는 표준 격리 수준인 아래 4가지만 사용한다:

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

나머지 2단계는 큐브리드 고유 개념이므로 이 글에서는 다루지 않는다.


## 큐브리드의 잠금 관리와 교착 상태
### 공유 잠금 (S_LOCK)
트랜잭션 `Tx1`이 **읽기 연산을 수행할 때** 해당 레코드에 대해 설정하는 잠금이다.

- 다른 트랜잭션(`Tx2`, `Tx3`)도 같은 레코드에 대해 **읽기 연산은 가능**하지만 **쓰기 연산은 불가능**하다.

#### READ COMMITTED에서의 S_LOCK
- 읽기가 완료되면 **즉시 공유 잠금을 해제**한다.
- 이로 인해 다른 트랜잭션이 갱신/삭제할 수 있어 **반복 불가능한 읽기(non-repeatable read)**가 발생할 수 있다.

#### REPEATABLE READ, SERIALIZABLE에서의 S_LOCK
- 트랜잭션이 커밋될 때까지 **공유 잠금을 유지**한다.
- 다른 트랜잭션은 해당 객체를 갱신하거나 삭제할 수 없다.
- 반복 불가능한 읽기가 발생하지 않는다.

### 배타 잠금 (X_LOCK)
트랜잭션이 **쓰기 연산을 수행하기 전** 설정하는 잠금으로, **오직 하나의 트랜잭션만 획득 가능**하다.
- 갱신 연산이 완료되어도 커밋 전까지는 잠금을 유지한다.
- 다른 트랜잭션은 **읽기 및 쓰기 모두 불가능**하다.

### 갱신 잠금 (U_LOCK)
UPDATE나 DELETE 수행 전, WHERE 절 조건을 확인하기 위해 **읽기 연산이 선행**될 때 사용되는 잠금이다.

- 예를 들어 `UPDATE tbl SET content='abc' WHERE id BETWEEN 10 AND 20` 구문이 있다면,  `id` 범위에 해당하는 레코드에 먼저 **U_LOCK**을 설정해 다른 트랜잭션이 해당 레코드를 선점하는 것을 방지한다.
- 다른 트랜잭션이 해당 레코드에 **S_LOCK**을 획득한 경우에도 **U_LOCK 획득 가능**하지만,  
    U_LOCK이 설정된 이후에는 **새로운 S_LOCK은 불가능**하다.
- 실제 갱신 시점에는 **U_LOCK → X_LOCK**으로 변경되며, 이때 기존의 S_LOCK이 해제되어 있어야 갱신이 수행된다.

읽기 및 갱신 질의 시 데이터에 대한 잠금 동작을 요약하면 다음과 같다.
![[IMG-20250705001728030.png|500]]
### 의도 잠금
큐브리드의 `의도 잠금(intent lock)`은 트랜잭션이 연산을 수행할 대상 객체보다 상위 계층의 객체에 대해 미리 잠금을 설정하는 방식이다. 

이는 하위 객체(예: 레코드)에 대한 잠금이 존재함을 알리는 신호로 사용되며, 상위 객체(예: 테이블)가 변경되지 않도록 보호한다.

즉, 특정 레코드에 쓰기 잠금을 획득하면 상위 객체인 테이블에도 잠금이 설정되므로, 다른 트랜잭션이 해당 테이블 스키마를 변경하거나 테이블 단위의 갱신을 실행하는 것을 막을 수 있다.

#### 의도 잠금의 종류

|잠금 종류|설명|
|---|---|
|**IS_LOCK (의도 공유 잠금)**|레코드에 S_LOCK이 설정되면 테이블에 IS_LOCK을 획득한다. 테이블 스키마 변경 및 전체 행 갱신은 불가, 일부 행 갱신 및 전체 행 조회는 가능|
|**IX_LOCK (의도 배타 잠금)**|레코드에 X_LOCK이 설정되면 테이블에 IX_LOCK을 획득한다. 테이블 스키마 변경, 전체 행 갱신, 전체 행 조회는 불가, 일부 행 갱신만 가능|
|**SIX_LOCK (공유 의도 배타 잠금)**|테이블에 설정되는 잠금. 스키마 변경, 일부/전체 행 갱신, 전체 행 조회는 불가, 일부 행 조회만 가능|


### 키 잠금(Key Lock)
**키 잠금(key lock)** 은 큐브리드에서 인덱스를 기준으로 **특정 범위에 대한 삽입/갱신/삭제 충돌을 방지하기 위해 설정하는 잠금 방식**이다. 트랜잭션이 INSERT, UPDATE, DELETE를 수행할 때 **자신의 키와 다음 키에 대해 잠금을 획득**하며, 유령 읽기(phantom read)를 방지하는 역할도 한다.

> **단, 키 잠금은 반드시 인덱스 스캔이 발생하는 WHERE 조건에서만 동작**한다.

#### 다음 키 잠금의 종류

|잠금 종류|설명|
|---|---|
|**NS_LOCK (next key shared lock)**|INSERT 수행 시 자신의 키와 다음 키에 공유 잠금을 획득. 삽입 후에는 자신의 키에만 유지됨|
|**NX_LOCK (next key exclusive lock)**|UPDATE/DELETE 수행 시 자신의 키와 다음 키에 배타 잠금을 획득|

![[IMG-20250705001902191.png|500]]
예시
```
-- WHERE ID BETWEEN 3 AND 10 조건이 있는 UPDATE문
-- 조건에 해당하는 키값이 3, 4, 7
-- 조건 외 범위의 가장 가까운 키값이 20이라면:
```
- 키값 3, 4, 7 → `X_LOCK`
- 키값 3, 4, 7, 20 → `NX_LOCK`

> 해당 범위 내에서 다른 트랜잭션은 INSERT, UPDATE, DELETE 불가


#### 키 잠금과 유령 읽기
트랜잭션 `Tx1`이 B+ 트리를 통해 특정 키를 수정한 뒤 다시 데이터를 읽는 사이에  
다른 트랜잭션 `Tx2`가 같은 범위 내에서 INSERT나 DELETE를 수행하면 **유령 읽기 현상**이 발생할 수 있다.

큐브리드는 이를 방지하기 위해 **다음 키 잠금**을 이용한다.

먼저 트랜잭션 처리 시 키 잠금이 없다면 어떤 현상이 발생할 수 있는지 알아보자.
![[IMG-20250705001941698.png|500]]
이제 큐브리드에서 키 잠금이 있을 때의 동작을 살펴보자. 앞의 예에서 Tx2가 INSERT 질의를 수행했을 때 생성된 인덱스 구조를 그림으로 살펴보면 다음과 같다.
![[IMG-20250705002019810.png|500]]
그림에서 점선 동그라미는 NX_LOCK을 의미하는데, Tx1이 키값 20에 대한 NX_LOCK을 보유한 상태 에서 Tx2는 키값 8의 다음 키값인 20에 대해 NS_LOCK을 획득하기 위해 대기한다.


### 스키마 잠금(Schema Lock)
큐브리드에서 DDL(데이터 정의어)을 수행할 때는 **스키마 수준의 잠금**이 설정된다.

|잠금 종류|설명|
|---|---|
|**SCH-S (Schema Stability Lock)**|질의 컴파일 중 설정. 다른 트랜잭션의 스키마 수정 차단|
|**SCH-M (Schema Modification Lock)**|DDL 실행 시 설정. 수정 중인 스키마에 접근 자체를 차단|

스키마 잠금은 테이블 구조나 인덱스를 변경하는 명령(CREATE, ALTER, DROP 등)을 처리하는 동안  
**다른 트랜잭션의 접근을 통제**하기 위한 보호 장치다.


### 예시
```sql
CREATE TABLE tbl(id INT PRIMARY KEY, a INT); 
INSERT INTO tbl VALUES (10, 10); 
INSERT INTO tbl VALUES (20, 20); INSERT INTO tbl VALUES (40, 40); 
COMMIT;
```
![[IMG-20250705002145767.png|500]]
작업 (4)와 (5)의 `BETWEEN` 범위가 다른 이유는 **키 잠금의 동작 특성**을 시뮬레이션하기 위함이다.  
SELECT 연산이 **30을 포함**하고, UPDATE 연산은 **30을 포함하지 않지만**  
25 다음 키가 30이므로 **30 키에 대해 간접적인 영향을 받는다.**

> `cubrid lockdb` 명령을 사용해 잠금 상태를 실시간으로 확인할 수 있다.



### 키 잠금과 교착 상태
키 잠금은 각 인덱스에서 **자신의 키 + 다음 키**에 대해 잠금을 설정한다.  
이때 여러 인덱스가 걸려있거나 다중 트랜잭션이 교차 접근할 경우 **교착 상태(deadlock)**가 발생할 수 있다.

#### 예제 시나리오
```sql
CREATE TABLE tbl3 (id INT); 
CREATE INDEX ix_tbl3_id ON tbl3 (id); 
INSERT INTO tbl3 VALUES (10), (20), (30), (40); 
COMMIT;
```

그 결과 다음 그림과 같은 인덱스 구조가 만들어진다.

![[IMG-20250705002431026.png|500]]

이때 트랜잭션 Tx1에서 키값 10을 35로 바꾸는 질의를 수행한다.
```sql
UPDATE tbl3 SET id=35 WHERE id=10; -- T1
```
1. Tx1은 키값 10의 다음 키값인 20에 잠금을 획득한다. 
2. Tx1은 키값 10을 지우고 키값 35를 넣기 위해 키값 40에도 잠금을 획득해야 한다.

![[IMG-20250705002528793.png|500]]
Tx1이 수행 중일 때 동시에 Tx2가 키값 30을 15로 바꾸는 질의를 수행한다.
```sql
UPDATE tbl3 SET id=15 WHERE id=30; -- T2
```
3. Tx2는 키값 30의 다음 키값인 40에 잠금을 획득한다. 
4. Tx2는 키값 30을 지우고 키값 15를 넣기 위해 키값 20에도 잠금을 획득해야 한다.

![[IMG-20250705002547798.png|500]]

이 작업이 (1)–(3)–(2)–(4)의 순서로 진행된다면 
`Tx1`은 (2) 작업 도중 Tx2가 보유한 키값 40에 대한 키 잠금을 
`Tx2`는 (4) 작업 도중 Tx1이 보유한 키값 20에 대한 키 잠금을 서로 요구하게 되면서 교착 상태가 발생한다. 
각 트랜잭션은 자신의 키뿐만 아니라 자신의 다음 키까지 잠가야 하므로 이러한 현상이 발생할 수 있는 것이다

![[IMG-20250705002553271.png|500]]

> Tx1, Tx2가 동시에 각각 UPDATE, UPDATE를 수행하거나 UPDATE, DELETE를 수행하거나, UPDATE, INSERT 를 수행하는 경우 등에서는 위와 같이 키의 범위가 겹치면서 잠금 방향이 엇갈리는 경우 교착 상태가 발생할 수 있다. 그러나 동시에 INSERT, INSERT를 수행하는 경우에는 각각 NS_LOCK을 요구하므로 같은 키에 대해 NS_LOCK의 공유가 가능해 교착 상태가 발생하지 않는다.(뭔말이지?)


## 교착 상태 발생 및 확인 시나리오
서버 오류 로그에 교착 상태와 관련된 오류가 출력됐다면 큐브리드 시스템이 이미 교착 상태를 찾아내어 어느 한쪽의 트랜잭션을 취소한 상태로, 교착 상태가 해소됐다고 볼 수 있다. 큐브리드 시스템이 교착 상태를 감지하면 즉시 교착 상태를 유발한 트랜잭션 중 하나를 취소하므로 cubrid lockdb 유틸리티를 사용해 교착 상태가 발생한 순간을 포착하기는 어렵다. 다만 교착 상태가 발생하면 큐 브리드 데이터베이스 서버의 이벤트 로그에 기록되므로 이 기록을 통해 교착 상태 정보를 확인할 수 있다.

### 두 트랜잭션의 교착 상태
두 트랜잭션 사이에서 발생할 수 있는 교착 상태의 예를 살펴보자.

```sql
INSERT INTO tbl VALUES (30, 30); -- Tx1, 성공 
UPDATE tbl SET SET a=1000 WHERE id BETWEEN 20 AND 25; --Tx2, 대기
```

![[IMG-20250705002649241.png|500]]
이제 교착 상태를 의도적으로 유발하기 위해 Tx1에서 20에 다음 UPDATE 문을 수행해보자.

```sql
UPDATE tbl SET a=2000 WHERE id=20; -- Tx1
```
이 UPDATE 문을 실행하면 두 트랜잭션 모두 서로의 잠금이 해제되기를 기다리는 상황이 되므로 교착 상 태에 놓이게 된다. 이를 그림으로 나타내면 다음과 같다

![[IMG-20250705002706977.png|500]]
그림에서 `Tx1`은 id 칼럼의 행 20에 대한 U_LOCK을 획득하기 위해 대기하며, 
`Tx2`는 id 칼럼의 키 30에 대한 NX_LOCK을 획득하기 위해 대기한다. 

즉, 화살표처럼 서로 상대방이 잠금을 해제하기를 기다리는 순환 대기(circular wait) 구조를 만들게 된다. 
큐브리드 시스템은 이러한 교착 상태를 즉시 탐지해, 둘 중 하나의 트랜잭션을 취소하면서 클라이언트에 다음과 같은 오류 메시지를 출력한다.

```
ERROR: Your transaction (index 1, DBA@ cubhost|31793) has been unilaterally aborted by the system.
```