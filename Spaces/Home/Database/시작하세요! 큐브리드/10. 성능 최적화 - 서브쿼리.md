## 서브쿼리
하나의 쿼리 내에 포함된 또 다른 쿼리를 의미한다. 주로 `SELECT`, `FROM`, `WHERE` 절 등 다양한 위치에 사용되며, 결과의 개수나 주 질의와의 관계 방식에 따라 여러 유형으로 나뉜다.

### 서브쿼리의 유형 분류
#### 1. 반환 건수에 따른 분류
|유형|설명|사용 가능한 연산자|
|---|---|---|
|단일 행 서브쿼리|한 건의 결과만 반환|`=`, `<`, `>`, `<=`, `>=`|
|복수 행 서브쿼리|여러 건의 결과 반환|`IN`, `ANY`, `SOME`, `EXISTS`|
|다중 칼럼 서브쿼리|여러 개의 칼럼을 반환|`(col1, col2) IN (...)` 형태로 비교|

> 단일 행 서브쿼리는 여러 위치에서 자유롭게 사용되지만, **SELECT 절에 올 수 있는 유일한 형태**이기도 하다. 복수 행 서브쿼리는 반드시 다중 결과에 대응하는 연산자와 함께 사용해야 한다.

#### 2. 주 질의와의 연관성에 따라 분류

| 유형      | 설명                 | 특징                                 |
| ------- | ------------------ | ---------------------------------- |
| 상관 서브쿼리  | 주 질의의 칼럼값에 의존하는 질의 | 주 질의의 각 행마다 **다시 실행**됨 (비효율 발생 가능) |
| 비상관 서브쿼리 | 단독으로 실행 가능한 질의     | 단 한 번 실행 후 결과 재사용 가능               |

### 스칼라 서브쿼리 vs 인라인 뷰
■ 스칼라 서브쿼리
```sql
SELECT a.code, a.name,
       (SELECT MAX(game_date)
        FROM game g1
        WHERE g1.athlete_code = a.code
          AND host_year = 2004) AS lastdate
FROM athlete a
WHERE a.nation_code = 'KOR'
  AND a.event = 'Archery';
```
- `athlete` 테이블의 각 행마다 `game` 테이블을 다시 탐색해야 한다.
- `game` 테이블에서 조건을 만족하는 `game_date`의 최대값을 찾기 위한 **반복 접근**이 발생.
- `athlete`의 결과 건수가 많을수록 성능이 떨어짐.

■ 인라인 뷰
```sql
SELECT a.code, a.name, g.lastdate
FROM athlete a
INNER JOIN (
    SELECT athlete_code,
           MAX(game_date) AS lastdate
    FROM game
    WHERE host_year = 2004
    GROUP BY athlete_code
) g ON a.code = g.athlete_code
WHERE a.nation_code = 'KOR'
  AND a.event = 'Archery';
```
- `game` 테이블을 먼저 집계해 **athlete_code 별로 최대값을 미리 계산**.
- 결과를 임시 테이블처럼 사용하여 `athlete`와 **한 번의 조인으로 처리**.
- 집계 대상이 적으면 매우 효율적이며, 반복 실행이 없다.

| 항목       | 스칼라 서브쿼리             | 인라인 뷰                                     |
| -------- | ------------------- | ----------------------------------------- |
| 동작 방식    | 주 질의의 각 행마다 서브쿼리 실행  | 서브쿼리 결과를 별도의 메모리 공간에 <br>임시 테이블로 만들어 놓고 조인 |
| 반복 실행 여부 | 많음                  | 없음                                        |
| 성능       | 주 질의 결과 건수가 많을수록 저하 | 초기 계산 비용은 있으나 안정적                         |
| 활용 시점    | 간단한 단일 조회 시         | 조인 및 집계 대상이 명확할 때                         |

### 복수 행 연산자
SQL에서 서브쿼리의 결과가 여러 행일 경우에는 반드시 복수 행 연산자를 사용해야 한다. 대표적인 복수 행 연산자는 다음과 같다

- `IN`
- `SOME`, `ANY` (기능적으로 동일)
- `ALL`
- `EXISTS`

이들 연산자는 **조건이 참이면 true를 반환**한다는 공통점이 있지만, **내부 동작 방식의 차이로 인해 성능에 차이가 발생**할 수 있다.

#### 내부 동작 비교
`IN, SOME, ANY, ALL`
이 연산자들은 서브쿼리의 결과에서 중복을 제거(DISTINCT)해 메모리에 임시 테이블을 만든 후 주 질의와 조인을 시도하며, 중복을 제거하는 과정에서 정렬이 발생한다. 이때 데이터양이 많으면 디스크의 임시 볼륨에서 정렬을 처리하므로 처리 속도가 떨어질 수 있다.

`EXISTS`
주 질의를 수행하면서 서브쿼리의 결과와 비교해서 만족하는 행을 찾아서 반환하므로 주 질의에 만족하는 행을 서브쿼리에서 찾기 위해 서브쿼리에서 랜덤 액세스가 발생할 수밖에 없다.

- **주 질의의 각 행마다** 서브쿼리를 실행하여 **조건을 만족하는 레코드가 존재하는지**를 확인.
- 서브쿼리가 `WHERE` 조건에 맞는 레코드를 찾는 즉시 **TRUE를 반환하고 종료**한다.
- 일반적으로 **결과 집합이 크지 않고 인덱스가 잘 구성된 경우에 매우 효율적**이다.

|항목|`IN`, `ANY`, `SOME`, `ALL`|`EXISTS`|
|---|---|---|
|동작 방식|서브쿼리 결과를 중복 제거 및 정렬 후 메모리에 저장|서브쿼리 결과가 존재하는지만 판단|
|중복 제거|수행됨 (DISTINCT)|필요 없음|
|정렬 발생 여부|있음|없음|
|결과 건수 많을 때|성능 저하 가능 (디스크 I/O 발생)|인덱스 조건 만족 시 빠름|
|실행 효율|정렬 및 중복 제거 비용 존재|조기 종료 가능성 높음|
