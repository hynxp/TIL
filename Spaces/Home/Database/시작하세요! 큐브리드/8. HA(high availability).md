## HA란 무엇인가
**HA(High Availability)** 는 하드웨어, 소프트웨어, 네트워크 등 어떤 구성 요소에 장애가 발생하더라도 서비스가 중단되지 않고 **365일 24시간 무중단으로 운영될 수 있도록 하는 기능**이다.

큐브리드에서는 **브로커 다중화와 데이터베이스 다중화**를 모두 포함해서 HA 기능이라고 부른다. 시스템에 **예기치 못한 장애가 발생했을 때 자동으로 대체 시스템이 동작**하도록 하여 **중단 시간을 최소화**하는 것이 목적이다. 이 외에도 **부하 분산(load balancing)** 등 운영 측면에서 여러 장점을 제공한다.


## 브로커 다중화
큐브리드의 브로커는 **응용프로그램과 데이터베이스 서버 간의 연결을 중계하는 컴포넌트**다.  
브로커는 다음과 같이 배치될 수 있다:

- 데이터베이스 서버와 동일한 장비에 설치
- 브로커 전용 장비에서 독립 실행
- 단일 장비에 여러 브로커 구성 가능
- 각기 다른 장비에 브로커 분산 구성 가능

브로커의 주요 기능은 **질의 파싱 및 실행 계획 생성**이며, 이 과정에서 CPU와 메모리를 사용한다.  
유입되는 트래픽이 많아지면 **브로커의 리소스 사용량도 많아지므로**, 브로커를 별도로 구성하면 **부하 분산 효과**를 얻을 수 있다.


### 브로커 다중화 활용 시나리오
응용프로그램은 브로커에 연결을 요청할 때 **우선순위를 지정**할 수 있으며, **읽기 전용 브로커를 별도로 지정**할 수도 있다. 
이를 통해 브로커 장비를 다중화하여 **부하를 분산하고**, 한쪽 브로커가 비정상 종료될 경우에도 **다른 브로커가 이를 대체**하여 **서비스 무중단**을 실현할 수 있다.
![[IMG-20250705002930213.png]]

예를 들어, 다음과 같은 구성이 가능하다:

- A, B 응용프로그램 → broker1
- C, D 응용프로그램 → broker2
- E, F 응용프로그램 → broker3

`broker1`이 비정상 종료되면 → `broker2`가 처리  
`broker2`까지 종료되면 → `broker3`가 전체 부하 처리


## 데이터베이스 다중화
큐브리드는 데이터베이스 볼륨을 여러 장비에 복제 구성하여 **하나의 마스터 노드와 다수의 슬레이브 또는 레플리카 노드**로 구성할 수 있다. 마스터 노드에 장애가 발생하면 슬레이브 노드가 마스터 역할을 대신 수행하는 **페일오버(failover)**가 가능하다.

### 노드 역할 정의

|노드 유형|설명|
|---|---|
|**마스터(Master)**|모든 쓰기 트랜잭션을 처리. 시스템의 기준 데이터 노드|
|**슬레이브(Slave)**|마스터 장애 시 자동 전환(failover). 쓰기 불가, 읽기 가능|
|**레플리카(Replica)**|마스터 데이터를 복제하지만 마스터 역할을 수행하지 않음. 읽기 전용 노드|
큐브리드는 트랜잭션 로그 복제를 통해 데이터를 동기화하며,  
마스터에서 생성된 로그를 슬레이브 또는 레플리카로 전송 후 반영하는 방식이므로 **슬레이브가 항상 최신 상태라는 보장은 없다.**

### 데이터베이스 다중화의 활용
큐브리드의 HA 구성은 다음과 같은 실제 서비스 환경에서 다양하게 활용될 수 있다.

#### 1. 데이터 분산
- 마스터 데이터와 동일한 데이터를 슬레이브 노드가 복제 보관
- IDC 이중화 가능 (예: 서울-부산)
- 단, 데이터 변경량이 많을 경우 복제 지연 발생 가능 → **빠르고 안정적인 네트워크 필요**

#### 2. 부하 분산
- 레플리카 노드는 **읽기 전용 브로커**를 통해 읽기 트랜잭션 분산 처리 가능
- 여러 대의 레플리카 노드를 구성하여 **확장성** 확보

→ 읽기 요청이 많은 시스템에서 효율적인 분산 처리 구조

#### 3. 백업 및 복구
- 슬레이브 노드 자체는 백업 용도는 아님
- 그러나 슬레이브에서 별도의 백업을 수행하여 **마스터 백업 부담을 줄일 수 있음**
- **복제 지연된 레플리카**를 두어 **삭제 전 상태 복원** 등에도 활용 가능

> 사용자가 실수로 데이터를 삭제한 경우, 삭제 로그 반영 전인 레플리카에서 복구한다.

#### 4. 운영 작업 및 장애 대응
- 마스터 장애 시 슬레이브 노드가 즉시 페일오버
- 마스터 노드 인덱스 생성, IDC 이전, DB 교체 등 운영 작업 시 **시스템 중단 최소화**


### HA 연결 관련 파라미터
![[IMG-20250705003145286.png]]

### 데이터베이스 서버 설정
#### `cubrid.conf` 파일 설정
- 마스터/슬레이브 노드: `ha_mode=on`
- 레플리카 노드: `ha_mode=replica`

마스터와 슬레이브는 **역할이 자동 전환될 수 있으므로 동일한 설정**을 사용한다.

#### 마스터 결정 방식
`cubrid_ha.conf`의 `ha_node_list` 항목에 명시된 **노드 구동 순서**에 따라 결정된다.

```
ha_node_list=nodeA:nodeB:nodeC
```

- nodeA가 먼저 구동 → 마스터 노드
- nodeA 종료 시 → nodeB가 마스터
- nodeB도 종료 시 → nodeC가 마스터


### 데이터베이스 다중화 구축 절차
1. 마스터 노드 정지
2. 마스터 노드 백업
3. 슬레이브 노드에 복구
4. 마스터 노드 구동
5. 슬레이브 노드 구동

> ✅ 복제 대상은 **기본 키가 존재하는 테이블**에 한정된다.  
> ✅ 마스터와 슬레이브의 **볼륨 디렉터리 구조는 동일**해야 한다.


## 복제
큐브리드 HA(High Availability) 기능의 핵심은 `복제(replication)`이다.
복제란 마스터 노드의 변경 데이터를 슬레이브 또는 레플리카 노드에 반영하는 기능이다. 
큐브리드는 단순히 질의문을 복제하는 방식이 아니라, 트랜잭션 로그(transaction log)를 기반으로 변경된 레코드를 복제하는 방식을 채택하고 있다.

### 복제 동작 원리
큐브리드에서는 데이터가 변경되면 트랜잭션 로그에 기록되고, **슬레이브 또는 레플리카 노드가 이 로그를 복사해 자신의 데이터베이스에 반영**하는 방식으로 복제가 이루어진다.

> ❗ 복제는 기본 키(primary key)를 기반으로 작동하기 때문에 **기본 키가 없는 테이블은 복제되지 않는다.**

### 마스터(nodeA):슬레이브(nodeB)=1:1로 구성한 HA 환경의 프로세스
![[IMG-20250705003354797.png]]



그림에서는 브로커를 b1과 b2 2개로 구성하고, 데이터베이스 서버를 nodeA와 nodeB 2개로 구성했다. 
nodeA 사각형과 nodeB 사각형 안의 타원은 프로세스다. 

HA 복제에 필요한 프로세스는 다음과 같다.
- **마스터 프로세스(cub_master)**: 노드 간 하트비트 메시지를 주고받으며, HA 상태를 제어한다.
- **복제 로그 복사 프로세스(copylogdb)**: 복제 대상 노드에 존재하며, 마스터 노드의 트랜잭션 로그를 가져온다.
- **복제 로그 반영 프로세스(applylogdb)**: 복사된 로그를 데이터베이스에 반영하기 위해 서버 프로세스에 요청을 보낸다.

슬레이브 노드는 마스터 노드의 데이터를 복사하지만, 페일오버 발생 후 마스터가 재기동되어 슬레이브로 역할이 변경될 수 있으므로, 마스터 노드 역시 슬레이브 노드의 변경 로그를 확보해 두어야 한다.
레플리카 노드는 마스터 노드의 데이터를 복사하되, 페일오버되지 않으므로 마스터가 레플리카의 로그를 가져올 필요는 없다.


### 복제 동작 흐름
#### 마스터에서 슬레이브로 데이터를 복제하는 과정
![[IMG-20250705003429315.png]]

#### 슬레이브에서 마스터로 데이터를 복제하는 과정
![[IMG-20250705003444012.png]]

큐브리드는 복제 로그를 재생(replay)해 마스터 노드의 데이터를 슬레이브 노드에 복제하는데, 복제 로그 는 테이블의 기본 키를 기반으로 생성된다. 따라서 기본 키가 없는 테이블은 복제 로그가 생기지 않아 복제 되지 않는다.

복제는 복제 로그 복사 프로세스가 트랜잭션 로그를 요청해 가져와 복제 로그에 저장하는 방식으로 작동한다. 즉, 로그를 받는 쪽이 능동적으로 끌어오는 pulling 방식이며, 마스터 노드에 HA 설정이 되어 있지 않아도 슬레이브 노드의 copylogdb는 로그를 가져올 수 있다. 이 구조 덕분에 서버 증설이나 IDC 이전 등 운영 중 작업도 복제를 통해 서비스에 영향을 주지 않고 수행할 수 있다.

복제 로그 반영 프로세스는 copylogdb가 저장한 복제 로그를 순차적으로 서버에 반영하며, 그 상태는 `db_ha_apply_info`라는 시스템 테이블에 기록된다. 이 테이블을 통해 복제 지연이나 실패 여부를 실시간으로 파악할 수 있다.

슬레이브 노드는 마스터 로그를 반영하고, 마스터 노드도 슬레이브 로그를 가져온다. 마스터는 슬레이브 로그를 반영하지는 않지만, HA 전환 시 어떤 트랜잭션 로그부터 복제해야 할지 결정하기 위해 로그를 확보해둔다.


### 복제 방식 (동기/비동기)
큐브리드는 동일 HA 그룹에 속한 모든 노드 간 트랜잭션 로그를 복사하여 각 노드를 동일 상태로 유지하는데, 이 구조는 **상호 복사 구조**이다. 이는 체인 구조보다 구성 및 장애 처리 면에서 유연하다는 장점이 있다.

큐브리드의 복제 동작 방식은 마스터가 트랜잭션 발생 시 로그 파일을 생성하고, 슬레이브 또는 레플리카가 이를 받아 트랜잭션을 해석하여 데이터베이스에 반영하는 방식이다.

복제는 다음 두 모드 중 하나로 동작한다

- **sync 모드**: 로그가 상대편 노드에 복사 완료된 시점에 마스터 트랜잭션 커밋 완료
- **async 모드**: 복사 여부와 무관하게 마스터 트랜잭션 커밋

`cubrid_ha.conf`의 `ha_copy_sync_mode` 파라미터로 설정한다.  
sync 모드는 데이터 정합성이 뛰어나지만 커밋 지연이 생기고, async 모드는 성능은 좋지만 장애 발생 시 노드 간 데이터 불일치 가능성이 있다.

### 복제 지연
복제 반영 상태는 다음 쿼리로 확인할 수 있다.
```sql
SELECT (last_access_time – log_record_time) FROM db_ha_apply_info;
```
멀티스레드로 처리되는 마스터와는 달리 슬레이브 노드는 로그 반영을 싱글 스레드로 처리하기 때문에 대량의 DML이 발생한 경우 복제 지연이 발생할 수 있다. 

이 상태에서 마스터가 장애가 나면 슬레이브에 반영이 완료되지 않아 페일오버가 실패할 수 있으므로, 복제 지연 상황에서 무조건 슬레이브를 재구축하기보다는 일정 시간 경과 후 해소 여부를 판단해야 한다.

## 다양한 HA 구성 사례
데이터베이스 다중화의 목적은 주로 페일오버와 읽기 부하 분산이다. 여기서는 가장 기본이 되는 마스터: 슬레이브=1:1 구성부터 시작해 다양한 구성을 살펴보겠다.

### 마스터:슬레이브 = 1:1 구성 (기본)
CUBRID HA의 기본 구성은 마스터:슬레이브=1:1 구성이다.
![[IMG-20250705003728540.png]]
그림에서 큰 사각형은 하나의 장비를 나타내고, 그 안의 모서리가 둥근 사각형은 브로커 프로세스를, 작은 사각형은 데이터베이스 서버 프로세스를 나타낸다. 
cubrid_broker.conf 파일의 ACCESS_MODE 파라 미터를 별도로 설정하지 않으면 브로커는 RW 모드로 동작한다. 
그리고 응용프로그램의 연결 URL에는 기 본 호스트를 nodeA, altHosts를 nodeB로 명시한다. 
이렇게 하면 응용프로그램은 nodeA에 먼저 접속을 시도하고, 응용프로그램이 접속한 브로커는 nodeA 데이터베이스에 접속을 완료한다.

#### ■ cubrid.conf
```
ha_mode=on
```
#### ■ cubrid_ha.conf
```
ha_port_id=59901 
ha_node_list=cubrid@nodeA:nodeB 
ha_db_list=testdb
```

### 브로커를 별도의 장비에 구성
![[IMG-20250705003751633.png]]
브로커는 별도의 장비에 구성해 설정할 수도 있다.


### 마스터:슬레이브 = 1:2 구성 (다중 슬레이브)
![[IMG-20250705003817289.png]]
슬레이브 하나로는 안심이 되지 않을 때 슬레이브를 이중으로 구성한다. 
즉, 마스터:슬레이브=1:2로 구성 하는 경우다. 물론 슬레이브 노드를 3대 이상 구성할 수도 있지만 슬레이브 노드의 복제 로그를 관리해야하는 마스터 노드의 부담이 가중되므로 보통은 2대를 초과하지 않는 편이다. 만약 읽기 부하 분산이 목적이 라면 레플리카 노드의 사용을 권장한다.


#### ■ cubrid.conf
```
ha_mode=on
```
#### ■ cubrid_ha.conf
```
ha_port_id=59901 
ha_node_list=cubrid@nodeA:nodeB:nodeC
ha_db_list=testdb
```

### 샤딩(Sharding) 구성
![[IMG-20250705004049118.png]]
 브로커 장애에 대비해 여러 대의 브로커를 추가하고, 매우 많은 양의 데이터에 대한 부하를 분산하기 위해 여러 대의 장비에 마스터 데이터베이스의 데이터를 나눠서 구성한 예다. 다음 그림에서 nodeA1~nodeA4의 데이터는 동일한 데이터가 아니고 분산된 것인데, 이런 구성을 샤딩이라고 한다.
 
한 대의 장비에서 마스터 데이터베이스의 데이터를 저장하고 트래픽을 수용할 수 없을 정도로 데이터 양이 매우 많은 경우, 데이터를 여러 대의 장비에 쪼개서 구성하는 샤딩 구성을 고려해 볼 수 있다. 샤딩 구성 시 각 장비에 저장된 스키마는 동일하지만 데이터는 특정 키를 기준으로 여러 대의 장비에 나뉘어 저장된다. 이때의 데이터 샤딩 알고리즘은 응용프로그램을 통해 직접 만들어 관리하거나 중간에 미들웨어를 둬서 처 리하기도 한다.

### 마스터 + 슬레이브 + 다중 레플리카 구성
브로커를 분리한 구성은 트래픽이 많은 경우에 유용하지만 결국 마스터 데이터베이스는 한 대이기 때문에 한 대의 마스터 데이터베이스가 수용할 수 있는 트래픽 범위 내에서만 유용하다. 
그런데 트래픽이 많은 서비스의 대부분은 읽기 부하가 차지하는 비중이 크기 때문에 다음 그림과 같이 레플리카 노드를 두어 부하 를 분산하는 형태로 복제를 활용할 수 있다.

- 마스터: 쓰기 처리
- 슬레이브: 페일오버 대비
- 레플리카(nodeA~nodeC): 읽기 부하 처리

![[IMG-20250705004114475.png]]
이 경우 nodeMaster와 nodeSlave는 다음과 같이 설정한다.

#### ■ cubrid.conf
```
ha_mode=on
```
#### ■ cubrid_ha.conf
```
ha_port_id=59901 
ha_node_list=cubrid@nodeMaster:nodeSlave 
ha_db_list=testdb 
ha_replica_list=cubrid@nodeA:nodeB:nodeC
```

nodeA~nodeC(레플리카 노드)는 다음과 같이 설정한다. 

■ cubrid.conf
```
ha_mode=replica
```
#### ■ cubrid_ha.conf
```
ha_port_id=59901 
ha_node_list=cubrid@nodeMaster:nodeSlave 
ha_db_list=testdb 
ha_replica_list=cubrid@nodeA:nodeB:nodeC
```


### 레플리카 활용 예
- **지연 복제 레플리카**
    - `ha_replica_delay` 설정으로 의도적 복제 지연
    - 단위: ms, s, min, h
    - 삭제 사고 발생 시, 과거 상태의 데이터 조회 및 복구 가능

- **레플리카에서의 쓰기**
    - 통계/배치 목적의 임시 테이블 생성 시 유용
    - 복제되지 않으며, 임시 목적에만 제한적으로 사용

## HA 제약 사항
큐브리드의 HA(High Availability) 기능을 구성할 때에는 다음과 같은 제약 사항들을 반드시 인지하고 시스템 설계 및 운영에 반영해야 한다. 이러한 제약 사항을 무시하면 정상적인 복제가 되지 않거나, 장애 발생 시 복구가 어렵고 데이터 불일치가 생길 수 있다.

- 큐브리드의 HA 기능은 **리눅스 계열 운영체제에서만 사용할 수 있다.**
    
- 테이블에는 반드시 **기본 키(primary key)**가 포함되어야 한다. 기본 키가 없는 테이블은 복제되지 않는다.
    
- **자바 저장 프로시저(JSP) 환경은 복제되지 않는다.**  
    따라서 JSP를 사용하는 경우, HA를 구성하는 모든 노드에 동일한 자바 저장 프로시저 환경을 별도로 설정해야 한다.
    
- `CALL` 문으로 호출되는 메서드(예: `login()`, `add_user()`, `drop_user()`, `change_owner()` 등)는 복제되지 않기 때문에 **HA 구성에서는 사용하지 않아야 한다.**
    
- 통계 정보를 생성하는 `UPDATE STATISTICS` 문도 복제되지 않는다.  
    따라서 슬레이브나 레플리카 노드에는 해당 명령을 **별도로 직접 수행**해야 한다.
    
- **시리얼 객체(serial object)**에 캐시를 사용하는 경우, 노드 간에 현재 시리얼 값이 일치하지 않는다.  다중 노드에서 시리얼 값을 정확히 일치시키려면 캐시 기능을 사용하지 않아야 한다.
    
- 백업 시 `-r` 옵션을 사용하면 복제에 필요한 보관 로그까지 삭제될 수 있으므로, **이 옵션은 HA 환경에서는 절대 사용하지 않아야 한다.**
    
- HA 환경에서 온라인 백업을 하려면 **데이터베이스 이름 뒤에 `@hostname`을 반드시 명시**해야 한다.


## 장애 처리 메커니즘
큐브리드 HA 환경에서의 장애 감지는 **cub_master 프로세스**를 통해 이뤄진다. 마스터 노드와 슬레이브 노드 각각에서 cub_master가 실행되며, **0.5초 간격으로 하트비트 메시지를 주고받는 UDP 통신**을 통해 서로의 생존 상태를 감시한다.

### 장애 감지 기준
- cub_master가 **3초 이상 하트비트를 받지 못하면**, 상대 노드를 **unknown 상태로 판단**한다.
- unknown 상태가 되면 해당 노드는 페일오버(failover) 대상이 될 수 있다.

### 노드 내부 프로세스의 장애 처리
cub_master는 자신이 실행되고 있는 노드 내부의 하위 프로세스를 감시한다.
![[IMG-20250705004312989.png]]
- 예를 들어 cub_server 프로세스가 비정상 종료되거나 응답이 없는 경우, cub_master는 cub_server에 재시작 요청을 보낸다.
    
- 만약 cub_server가 **2분 이내에 재시작 요청을 반복해서 받거나 재시작에 실패하면**, 해당 노드는 HA 환경에서 제외되며 슬레이브 노드로 강등된다(demote).

### 마스터 프로세스 장애

![[IMG-20250705004322065.png]]
- cub_master 자체가 장애가 나면 하위 모든 프로세스는 정지된다.

- 다른 노드의 cub_master는 하트비트를 수신하지 못하게 되고, 현재 마스터 노드가 장애라고 판단하여 **자신이 새로운 마스터 노드로 전환된다.**

![[IMG-20250705004330772.png]]

> 큐브리드 9.2 이상 버전에서는 디스크 장애를 감지하기 위한 조건을 추가했는데, 마스터 노드에서 동작 중인 cub_ master 프로세스가 주기적으로 활성(active) 로그의 로그 변경까지 감지해 디스크 장애 여부를 판단하고, 장애로 판단되면 해당 서버는 페일오버된다.