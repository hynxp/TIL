
## 네트워크 기기
### 네트워크 기기의 처리 범위
네트워크 기기는 계층별로 처리범위를 나눌 수 있는데, 물리 계층을 처리할 수 있는 기기와 데이터 링크 계층을 처리할 수 있는 기기 등이 있다. 

- 애플리케이션 계층 : L7 스위치
- 인터넷 계층 : 라우터, L3 스위치
- 데이터 링크 계층 : 브리지, L2 스위치
- 물리 계층 : NIC, 리피터, AP

> 상위 계층을 처리하는 기기는 하위 계층을 처리할 수 있지만 그 반대는 불가능하다. 예를들어 L7 스위치는 애플리케이션 계층을 처리하는 기기로, 그 밑의 모든 계층의 프로토콜을 처리할 수는 있지만 AP는 물리 계층밖에 처리하지 못한다.



### 애플리케이션 계층을 처리하는 기기

#### L7 스위치
> `스위치`는 여러 장비를 연결하고 데이터 통신을 중재하며 목적지가 연결된 포트로만 전기 신호를 보내 데이터를 전송하는 통신 네트워크 장비이다.

![[IMG-20250608193545020.png]]
L7 스위치는 `로드밸런서`라고도 하며, 서버의 부하의 분산하는 기기로, 클라이언트로부터 오는 요청들을 뒤쪽의 여러서버로 나누는 역할을 하며 시스템이 처리할 수 있는 트래픽 증가를 목표로 한다. 

URL, 서버, 캐시, 쿠키들을 기반으로 트래픽을 분산하며, 바이러스나 불필요한 외부 데이터 등을 걸러내는 필터링 기능 또한 가지고 있으며 응용 프로그램 수준의 트래픽 모니터링도 가능하다.  
만약 장애가 발생한 서버가 있다면 이를 트래픽 분산 대상에서 제외해야 하는데, 이는 정기적으로 헬스 체크(health check)를 이용하여 감시하면서 이루어진다.

> 💡 **L4 스위치와 L7 스위치 차이**
> `L4 스위치`는 전송 계층을 처리하는 기기로 스트리밍 관련 서비스에서는 사용할 수 없으며, 메시지를 기반으로 인식하지 못하고 IP와 포트를 기반으로(특히 포트기반) 트래픽을 분산한다.  
> `L7 로드밸런서`는 IP, 포트 외에도 URL, HTTP 헤더, 쿠키 등을 기반으로 트래픽을 분산한다.  
> 
> ex) 클라우드 서비스에서 L7 스위치를 이용한 로드밸런싱은 ALB(Application Load Balancer) 컴포넌트로 하며, L4 스위치를 이용한 로드밸런싱은 NLB(Network Load Balancer) 컴포넌트로 한다.


**헬스 체크**
`헬스체크`란 전송 주기와 재전송 횟수 등을 설정한 이후 반복적으로 서버에 요청을 보내는 것을 말하며, 헬스 체크를 통해 서버의 정상여부를 판별할 수 있다.  

TCP, HTTP 등 다양한 방법으로 요청을 보내며 이 요청이 정상적으로 이루어졌다면 정상적인 서버로 판별한다. ( 예를 들어 TCP 요청을 보냈는데 3-웨이 핸드셰이크가 정상적으로 일어나지 않으면 정상이 아닌 것)


**로드밸런서를 이용한 서버 이중화**
![[IMG-20250608193545133.png|400]]
- 2대 이상의 서버를 기반으로 가상 IP를 제공하고 이를 기반으로 안정적인 서비스를 제공한다.  
- 예시 그림처럼 로드밸런서가 제공한 `0.0.0.12010`이란 가상 IP에 사용자들이 접근하고 뒷단에 사용 가능한 서버인 `0.0.0.12011`과 `0.0.0.12012`를 기반으로 서빙한다. 이렇게 하면 0.0.0.12011이란 서버에 장애가 발생해도 그것과는 무방하게 0.0.0.12012 서버를 기반으로 안정적인 서비스를 운영할 수 있다.


### 인터넷 계층을 처리하는 기기
#### 1. 라우터
![[IMG-20250608193545343.png]]
라우터(router)는 여러 개의 네트워크를 연결, 분할, 구분시켜주는 역할을 하며, 다른 네트워크에 존재하는 장치끼리 서로 데이터를 주고 받을 때 패킷 소모를 최소화하고 경로를 최적화하여 최소 경로로 패킷을 포워딩하는 라우팅을 하는 장치이다.


#### 2. L3 스위치
`L2스위치`의 기능과 `라우팅` 기능을 갖춘 장비를 말하며, L3스위치를 라우터라 해도 무방하다.
라우터는 소프트웨어 기반의 라우팅과 하드웨어 기반의 라우팅을 하는 것으로 나눠지고 하드웨어 기반의 라우팅을 담당하는 장치를 L3 스위치라고 한다.


| 구분     | L2 스위치     | L3 스위치  |
| ------ | ---------- | ------- |
| 참조 테이블 | MAC 주소 테이블 | 라우팅 테이블 |
| 참조 PDU | 이더넷 프레임    | IP 패킷   |
| 참조 주소  | MAC 주소     | IP 주소   |


### 데이터 링크 계층을 처리하는 기기

#### 1. L2 스위치
![[IMG-20250608193545414.png]]
장치들의 MAC 주소를 MAC 주소 테이블을 통해 관리하며, 연결된 장치로부터 패킷이 왔을 때 패킷 전송을 담당한다.

- 이를 위해 MAC 주소 테이블을 사용함 (IP주소 이해 불가)
- 목적지가 MAC 주소 테이블에 없다면 전체 포트 전달
- 주소는 일정 시간 이후 삭제하는 기능도 있다

> 💡 **MAC (Media Access Control Address)** 
> - MAC 주소는 간단히 말해 인터넷을 할 수 있는 이더넷 기반 기기에는 모두 다 하나씩 할당되어 있는 고유한 ID이다

#### 2. 브릿지
![[IMG-20250608193545512.png|500]]
두 개의 근거리 통신망(LAN)을 상호 접속할 수 있도록 하는 통신망 연결 장치로, 포트와 포트 사이의 다리 역할을 하며 장치에서 받아온 MAC 주소를 MAC 주소 테이블로 관리한다.
**즉, 통신망 범위를 확장하고 서로 다른 LAN 등으로 이루어진 '하나의' 통신망을 구축할 때 쓰인다**


### 물리 계층을 처리하는 기기

#### 1. NIC(Network Interface Card))
LAN카드라고 하는 `네트워크 인터페이스 카드`는 2대 이상의 컴퓨터 네트워크를 구성하는 데 사용하며, **네트워크와 빠른 속도로 데이터를 송수신 할 수 있도록 컴퓨터 내에 설치하는 확장 카드**이다.  
각 LAN 카드에는 각각을 구분하기 위한 고유의 식별번호인 **MAC 주소**가 있다.

#### 2. 리피터(repeater)
![[IMG-20250608193545593.png|400]]
들어오는 **약해진 신호 정도를 증폭하여 다른 쪽으로 전달하는 장치**를 말한다.  
이를 통해 패킷이 더 멀리 갈 수 있으나 광케이블의 보급으로 인해 현재는 잘 쓰이지 않는다.

#### AP (Access Point)
![[IMG-20250608193545701.png|300]]
패킷을 복사하는 기기로, AP에 유선 LAN을 연결한 후 다른 장치에서 와이파이와 같은 무선 LAN 기술을 사용하여 무선 네트워크 연결을 할 수 있다.

---
## IP 주소
앞서 인터넷 계층에 IP 주소를 쓴다고 했는데 IP 주소에 대해 좀 더 자세히 알아보자.

### ARP (Address Resolution Protocol)
컴퓨터와 컴퓨터 간의 통신은 흔히 IP 주소 기반으로 통신한다고 하지만, 정확히는 IP 주소에서 ARP를 통해 MAC 주소를 찾아 MAC 주소를 기반으로 통신한다
![[IMG-20250608193545802.png|500]]

- `ARP`는 가상 주소인 IP 주소를 실제 주소 MAC주소로 변환할 때 다리 역할을 하는 프로토콜이다.
  - IP(가상 주소) -> `ARP` -> MAC(실제 주소)
- `RARP`는 반대로 실제 주소인 MAC 주소를 가상 주소인 IP 주소로 변환
  - MAC(실제 주소) -> `RARP` -> IP(가상 주소)

![[IMG-20250608193545900.png|500]]

`장치 A`가 'ARP Request 브로드캐스트'를 보내서 IP 주소인 120.70.80.3에 해당하는 MAC 주소를 찾은 후, 해당 주소에 맞는 `장치 B`가 'ARP reply 유니캐스트'를 통해 MAC 주소를 변환하는 과정을 거쳐 IP 주소에 맞는 MAC 주소를 찾게 된다.

> 💡 **브로드캐스트란?**
> 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식
> 
> 💡 **유니캐스트란?**
> 고유 주소로 식별된 하나의 네트워크 목적지에 1:1로 데이터를 전송하는 방식


### 홉 바이 홉 통신
![[IMG-20250608193546000.png|500]]
IP주소를 통해 통신하는 과정을 뜻하며, 건너뛰는 모습을 뜻하는 홉(hop)을 이용해 통신망에서 각 패킷이 여러 개의 라우터를 건너가는 모습을 비유적으로 표현한 것이다.

즉, 통신 장치에 있는 '라우팅 테이블'의 IP를 통해 시작 주소로부터 시작하여 다음 IP로 계속해서 이동하는 라우팅_(IP 주소를 찾아가는 과정)_ 과정을 거쳐 패킷이 최종 목적지까지 도달하는 통신을 말한다.

#### 라우팅 테이블(routing table)  
`송신지에서 수신지까지 도달하기 위해 사용되며 라우터에 들어가 있는 목적지 정보들과 그 목적지로 가기 위한 방법이 들어있는 리스트`를 뜻한다.  
게이트웨이와 모든 목적지에 대해 해당 목적지에 도달하기 위해 거쳐야 할 다음 라우터의 정보를 가지고 있다.  
  

#### 게이트웨이(gateway)  
서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 관문 역할을 하는 컴퓨터나 소프트웨어를 일컫는 용어이다.  
사용자는 인터넷에 접속하기 위해 수많은 게이트웨이를 거쳐야 하며 게이트웨이는 `서로 다른 네트워크상의 통신 프로토콜을 변환해주는 역할`을 하기도 한다.  
게이트웨이는 라우팅 테이블을 통해 볼 수 있으며 명령프롬포트에서 netstat -r 명령어를 실행하여 확인할 수 있다.


### IP 주소 체계
![[IMG-20250608193546108.png|500]]#

#### IPv4
- 32비트를 8비트 단위로 점을 찍어 표기 (ex- 255.255.255.0)

#### IPv6
- 128비트를 16비트 단위로 점을 찍어 표기 (ex- 2001:db8::ff00:42:8329)
- IPv4의 한계를 극복하기 위해 나타난 방식이지만, IPv4에 비해 보급이 더디다.

### 클래스 기반 할당 방식(Classful Addressing)
인터넷이 처음 설계될 당시, IP 주소를 보다 간단히 관리하기 위해 ‘클래스 기반 할당 방식(Classful Addressing)’이라는 방식을 사용했다. 
이 방식은 `IP 주소를 A, B, C, D, E 다섯 개의 클래스로 나누어 각 클래스에 따라 주소 범위와 용도를 구분하는 것`이다.

#### 각 클래스의 용도와 범위

![[IMG-20250608193546198.png]]
- **클래스 A**는 대규모 네트워크, 예를 들면 대기업이나 정부 기관 등을 위해 설계되었다. 주소 범위는 0.0.0.0부터 127.255.255.255까지이며, 첫 번째 비트가 항상 0이다. 전체 32비트 중 처음 8비트는 네트워크 식별자로, 나머지 24비트는 호스트 식별자로 사용되므로 하나의 클래스 A 네트워크 안에 약 1,670만 개의 IP를 할당할 수 있다.
    
- **클래스 B**는 중간 규모의 조직을 위한 것으로, 주소 범위는 128.0.0.0부터 191.255.255.255이다. 앞의 두 비트가 10으로 고정되어 있고, 16비트씩 네트워크와 호스트를 나누기 때문에 하나의 네트워크 안에 약 6만 5천 개의 주소를 사용할 수 있다.
    
- **클래스 C**는 소규모 조직, 즉 가정이나 중소기업 등에 적합하다. 주소 범위는 192.0.0.0부터 223.255.255.255이고, 앞의 세 비트가 110으로 고정된다. 네트워크 부분은 24비트, 호스트 부분은 8비트로 구성되어 총 256개의 주소를 가질 수 있으나, 실제로는 네트워크 주소와 브로드캐스트 주소를 제외한 254개만 사용 가능하다.
    
- **클래스 D**는 일반적인 통신이 아닌 **멀티캐스트 통신**에 사용되며, 224.0.0.0부터 239.255.255.255까지의 범위를 갖는다. 이는 한 명이 여러 명에게 동시에 데이터를 전송할 때 쓰인다.
    
- **클래스 E**는 **실험용/예비용**으로 남겨놓은 주소로, 240.0.0.0부터 255.255.255.255까지 사용된다. 일반적인 네트워크 환경에서는 사용하지 않는다.

#### 구분 비트란?
![[IMG-20250608193546295.png|500]]
IP 주소는 2진수로 구성되므로, 각 클래스는 특정 비트 패턴으로 시작된다. 
이를 ‘구분 비트’라고 하며, 이 비트를 통해 어떤 클래스에 속하는 IP인지 판별할 수 있다.

- 클래스 A: 맨 앞 비트가 0
    
- 클래스 B: 앞 2비트가 10
    
- 클래스 C: 앞 3비트가 110

예를 들어, 12.0.0.0이라는 IP는 12를 2진수로 바꾸면 00001100인데, 가장 앞 비트가 0이므로 클래스 A에 속한다.

#### 네트워크 주소와 브로드캐스트 주소

![[IMG-20250608193546374.png|500]]
하나의 네트워크 안에서 첫 번째 주소는 **네트워크 주소**로, 마지막 주소는 **브로드캐스트 주소**로 예약되어 있다.

예를 들어, `12.0.0.0`이라는 클래스 A 네트워크를 부여받았다면 실제로 사용 가능한 호스트 IP 주소는 다음과 같다:

- `12.0.0.0`: 네트워크를 대표하는 주소. 사용 불가.
    
- `12.255.255.255`: 브로드캐스트 주소. 이 주소로 보내면 같은 네트워크에 속한 모든 기기에 데이터가 전달된다. 사용 불가.
    
- `12.0.0.1`부터 `12.255.255.254`까지: 실제 사용할 수 있는 호스트 주소.

즉, IP 주소의 전체 범위 중 양 끝(처음과 마지막)은 특별한 의미가 있기 때문에 일반 호스트에 할당할 수 없고, 그 사이의 주소만 실제 장비에 할당 가능하다.

#### 클래스 기반 방식의 한계
하지만 이 방식은 사용하는 주소보다 버리는 주소가 더 많은 단점이 있었고 이를 해소하기 위해 DHCP와 IPv6, NAT가 나오게 되었다.


### DHCP (Dynamic Host Configuration Protocol)
- IP 주소 및 기타 통신 매개변수를 자동으로 할당하기 위한 네트워크 관리 프로토콜
- 네트워크 장치의 IP 주소를 수동으로 설정할 필요 없이 인터넷에 접속할 때 마다 자동으로 IP주소 할당 가능
- 많은 라우터,게이트웨이 장비에 이 기능이 있고, 이를 통해 대부분의 가정용 네트워크에서 IP 주소를 할당한다

### NAT (Network Address Translation)
- 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소를 수정하여 IP 주소를 다른 주소로 매핑하는 방법이다.
- IPv4 주소 체계만으로는 많은 주소들을 모두 감당하지 못하는 단점이 있어, 이를 해결하기 위해 NAT로 공인 IP와 사설 IP로 나누어 많은 주소를 처리한다.
- NAT를 가능하게 하는 소프트웨어로는 ICS(산업 제어 시스템), RRAS(라우팅 및 원격 액세스 서비스), Netfilter(넷필터,리눅스 커널 내부의 네트워크 관련 프레임워크)등이 있다.

아래 그림처럼 하나의 IP(121.165.151.200)를 기반으로 각각의 다른 IP(192.168.0.x)를 가지는 것처럼 인터넷을 사용할 수 있으며, 사설 IP를 NAT 장치를 통해 하나의 공인 IP로 외부 인터넷에 요청할 수 있고 반대로 공인 IP를 사설 IP로 변환하기도 한다.
![[IMG-20250608193546555.png]]
#### 장점 
  - 내부 네트워크에서 사용하는 IP 주소와 외부에 드러나는 주소를 다르게 유지할 수 있기 때문에 내부 네트워크에 대한 어느 정도의 **보안** 기능을 한다
#### 단점
  - 여러 명이 동시에 인터넷을 접속하게 되므로, 실제로 접속하는 호스트 숫자에 따라서 **접속 속도**가 느려질 수 있다

#### 공유기와 NAT  
NAT를 쓰는 이유는 주로 여러 대의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위함이다. 예를 들어 `인터넷 회선 하나를 개통하고 인터넷 공유기를 달아서 여러 PC를 연결하여 사용`할 수있는데, 인터넷 공유기에 NAT 기능이 탑재되어 있기 때문에 가능한 것이다.


### IP 주소를 이용한 위치 정보
IP 주소는 **인터넷에서 사용하는 네트워크 주소**이기 때문에 이를 통해 동 또는 구까지 위치 추적이 가능하다

---
## HTTP
### HTTP/1.0
![[IMG-20250608193546704.png|300]]
- 한 연결당 하나의 요청을 처리한다 -> RTT 증가
- 그래서 요청 하나당 3 Way-Handshake등의 과정을 거쳐야 한다 -> RTT 증가
- 이를 해결하기 위해 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩을 사용하곤 하였다

> 💡 **RTT(Round Trip Time)란?**
> 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 패킷 왕복시간


#### RTT 증가를 해결하기 위한 방법
- 이미지 스플리팅  
    많은 이미지를 다운받게 되면 과부하가 걸리기 때문에 많은 이미지가 합쳐져 있는 하나의 이미지를 다운로드 받고, 이를 기반으로 background-image의 position을 이용하여 이미지를 표기하는 방법이다.  
    
- 코드 압축  
    코드를 압축하여 개행 문자, 빈칸을 없애 코드의 용량을 최소화하는 방법이다.  
    
- 이미지Base64 인코딩  
    이미지 파일을 64진법으로 일워진 문자열로 인코딩하는 방법으로, 이 방법의 장점은 서버와의 연결을 열고 이미지에 대해 서버에 HTTP 요청을 할 필요가 없지만 Base64 문자열로 반환할 경우 크기가 37%정도 커지는 단점이 있다.


### HTTP/1.1
![[IMG-20250608193546808.png|500]]
- HTTP/1.0에서 발전한 것
- 매번 TCP 연결을 하는 것이 아니라, 한번 TCP를 초기화 한 후 Keep-alive 옵션으로 여러개의 파일을 송수신 하게 바뀌었다.
- HTTP/1.0에서도 keep-alive가 있었지만 표준화가 되어 있지 않았고 HTTP/1.1부터 표준화가 되어 기본 옵션으로 설정되었다

> 💡 **HOL Blocking(Head Of Line Blocking)**
> HTTP/1.x 버전에서 발생하는 문제로, 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상을 말한다
> ![[IMG-20250608193546902.png|500]]
> 위 세 파일을 받을 때 image.jpg  파일이 느리게 받아진다면 그 뒤에 있는 것들이 대기하여 다운로드가 지연되는 상태가 되는 것이다.
> 
> 💡 **무거운 헤더 구조**  
> HTTP/1.1의 헤더에는 쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무거웠다.


### HTTP/2
- SPDY 프로토콜에서 파생된 HTTP/1.x 보다 지연 시간을 줄이고 응답을 더 빠르게 할수 있다
- _멀티플렉싱, 헤더 압축, 서버 푸시_, 요청의 우선순위 처리를 지원한다

#### 멀티 플렉싱
![[IMG-20250608193547009.png|500]]
  - 여러 개의 스트림을 사용하여 송수신한다
  - 특정 스트림의 패킷이 손실되었다고 해도 해당 스트림에만 영향을 미친다 (나머지는 멀쩡)

> 스트림: 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소

하나의 연결 내 여러 스트림을 캡처해 병렬적인 스트림을 통해 데이터를 서빙하고 내부의 데이터들도 쪼개져 있다. 애플리케이션에서 받아온 메시지를 독립된 프레임으로 조각내어 서로 송수신한 이후 다시 조립하며 데이터를 주고받는다.  

![[IMG-20250608193547102.png|600]]
이를 통해 단일 연결을 사용하여 병렬로 여러 요청을 받을 수 있고 응답을 줄 수 있어 HOL Bolocking을 해결할 수 있다


#### 헤더 압축
  - HTTP/1.x 에는 크기가 큰 헤더라는 문제가 있었다
  - 허프만 코딩(huffman coding)알고리즘을 이용하여, 문자열을 문자 단위로 쪼개, 전체 데이터의 표현에 필요한 비트양을 줄이게 되었다

#### 서버 푸시
![[IMG-20250608193547229.png|500]]
  - 기존에는 클라이언트가 서버에 요청을 해야 파일을 다운로드 받을 수 있었지만, HTTP/2에서는 서버가 클라이언트로부터의 요청 없이 리소스를 바로 푸시할 수 있다

### HTTPS
- HTTP/2는 HTTPS 위에서 동작한다. HTTPS는 애플리케이션 계층와 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청을 말하며 이를 통해 통신을 암호화한다.

#### SSL/TLS(Secure Socket Layer/Transport Layer Security Protocol)
- SSL은 1.0부터 SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.3 까지 버전이 올라가며 마지막으로 TLS로 명칭이 변경되었으나, 보통 이를 합쳐 SSL/TLS로 많이 부른다.  
  
- `SSL/TLS는 전송 계층에서 보안을 제공하는 프로토콜`로 클라이언트가 서버가 통신할 때 SSL/TLS를 통해 제 3자가 메시지를 도청하거나 변조하지 못하도록 하며 공격자가 서버인 척하며 사용자 정보를 가로채는 '인터셉터'를 방지할 수 있다.  
  
- SSL/TLS는 `보안 세션을 기반으로 데이터를 암호화`하며 보안 세션이 만들 어질 때 인증 메커니즘, 키 교환 알고리즘, 해싱 알고리즘이 사용된다.

> 💡 **보안 세션**
> - 보안이 시작되고 끝나는 동안 유지되는 세션
> - SSL/TLS는 HandShake를 통해 보안 세션을 생성하고, 이를 통해 상태 정보 등을 공유

#### 인증 메커니즘
CA(Certificate Authoritties, 인증기관)에서 발급한 인증서를 기반으로 이루어지며, 이 인증서는 안전한 연결을 시작하는 공개키를 클라이언트에 제공하고 사용자가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다. 인증서는 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어져 있다.  
  
> 💡  **_디피-헬만 키 교환 암호화 알고리즘(Diffie-Hellman key exchange)_**
> 처음에 공개 값을 공유하고 각자의 비밀 값과 혼합한 후 혼합 값을 공유한 다음 각자의 비밀 값과 또 혼합하면 공통의 암호키가 생성된다. 이렇게 클라이언트와 서버 모두 개인키와 공개키를 생성하고 서로에게 공개키를 보내고 공개키와 개인키를 결합하여 PSK(사전 합의된 비밀키)가 생성된다면, 악의적인 공격자가 개인키 또는 공개키를 가지고도 PSK가 없기 때문에 아무것도 할 수 없기 때문에 이를 통해 키를 암호화할 수 있는 것이다.
> 
> 💡  **해싱 알고리즘**  
> 데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘이다.  
> SSL/TLS는 해싱 알고리즘으로 SHA-256 알고리즘과 SHA-384 알고리즘을 가장 많이 쓴다. 
> 
> 💡  **SHA-256 알고리즘**
> 해시함수의 결괏값이 256비트인 알고리즘이며 비트 코인을 비롯한 블록체인 시스템에서도 많이 쓴다.  
> 해싱을 해야 할 메시지에 1을 추가하는 등 전처리를 하고 전처리된 메시지를 기반으로 해시를 반환한다.  
> TLS 1.3은 사용자가 이전에 방문한 사이트로 다시 방문한다면 SSL/TLS에서 보안 세션을 만들 때 걸리는 통신을 하지 않아도 되는데 이를 0-RTT라고 한다.  


### HTTP/3
![[IMG-20250608193547322.png|300]]
- TCP가 아닌 UDP 기반
- TCP 위에서 돌아가는 HTTP/2와는 달리 HTTP/3은 `QUIC`이라는 계층 위에서 돌아간다
  - QUIC는 TCP를 사용하지 않기에 통신을 시작할 때 3 Way-Handshake같은 과정을 거치지 않는다 -> **지연 시간을 감소**하는 장점이 있다 

#### 초기 연결 설정 시 지연 시간 감소
QUIC은 첫 연결 설정에 1-RTT만 소요되는데 이는 클라이언트가 서버에 어떤 신호를 한번주고, 서버도 거기에 응답하기만 하면 본 통신을 바로 시작할 수 있다는 뜻이다.   
QUIC은 FEC(Forword Error Correction, 순방향 오류 수정 매커니즘)이 적용되어, 전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식으로 네트워크 환경이 열악해도 패킷 손실률이 낮다.



참고
https://pyoungt.tistory.com/241
https://github.com/hongxeob/CS-Study/tree/main/2.%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC(2)