## 트랜잭션과 무결성
### 트랜잭션
> 트랜잭션은 **DB에서 하나의 논리적 기능을 수행하기 위한 연산 단위**를 말한다  
> 즉 **여러 개의 쿼리들을 하나로 묶는 단위**를 말한다


### 트랜 잭션의 특징
트랜 잭션의 특징 4개를 `ACID`(Atomicity, Consistency, Isolation, Durability)라고 부른다

#### 1) 원자성 (Atomicity)
> **"all or nothing"**

**트랜잭션 내의 내용들이 하나의 단위(atomic)로 묶여서, 전체가 수행되거나 전체가 수행되지 않아야 한다는 속성**을 가리킨다
위의 예시에서 A가 B에게 돈을 보내줄 때 일어나는 세 가지 연산이 모두 실행되거나, 모두 실행되지 않아야 하는 성질을 말한다

`commit`
- 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
- 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말한다

`rollback`
- 에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야 할 때 사용한다
- 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)을 말한다

DBMS는 `commit`과 `rollback`을 통해 트랜잭션의 무결성이 보장된다!


- **트랜 잭션 전파**
트랜잭션을 수행할 때 커넥션 단위로 수행하는데, 커넥션 객체를 매번 넘겨서 트랜잭션을 수행하는 대신, 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶는 것
```java
@Service
public Class MemberService {
    ...
    @Transactional
    public HashMap<String, String> updateClassMember(Map<String, Object> param) throws Exception {
        ...
    }
}
```
Spring 프레임워크에서는 `@Transactional`이라는 어노테이션을 통해 트랜 잭션 전파를 처리한다.

#### 2) 일관성 (Consistency)
허용된 방식으로만 데이터를 변경해야하는 것을 의미한다
- 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 한다.
- ex) 잔고 0원으로부터 500만원 송금 불가능

#### 3) 격리성 (Isolation)
트랜잭션 수행 시 서로 끼어들지 못하는 것
- 복수의 병렬 트랜잭션은 서로 격리되어 **마치 순차적으로 실행**되는 것처럼 작동돼야 함
- 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 함
- 격리성은 여러 개의 격리 수준으로 나뉘어 격리성 보장

💡 [[트랜잭션의 격리 수준(Transaction Isolation Level)]
![[IMG-20250609200604453.png|400]]

|수준|내용|단점|
|:-:|---|---|
|SERIALIZABLE|순차적으로 진행시키는 것|교착 상태가 일어날 확률이 높음|
|REPEATABLE_READ|행 수정은 불가능하지만 행 추가는 가능|이후에 추가된 행이 발견될 수 있음|
|READ_COMMITTED|커밋하지 않은 정보는 읽을 수 없음|동시에 접근 가능하여 다른 내용이 발견될 수 있음|
|READ_UNCOMMITTED|커밋되기 이전에 다른 트랜잭션에 노출됨|무결성이 유지되지 않을 수 있음|
🔗 `SERIALIZABLE` : 트랜잭션을 순차적으로 진행
- 여러 트랜잭션이 동시에 같은 행 접근 불가
- 매우 엄격한 수준
- 교착상태가 일어날 확률 ⬆️
- 가장 성능이 떨어짐

🔗 `REPEATABLE_READ`
- 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아줌
- 다른 트랜잭션이 새로운 행을 추가하는 것은 막지 않음

🔗 `READ_COMMITTED` : 가장 많이 사용되는 격리 수준
- 커밋 완료된 데이터에 대해서만 조회를 허용
- 한 트랜잭션이 접근한 행을 다른 트랜잭션이 수정 가능
- A가 수정하고 B가 다시 수정한 행을 A가 다시 읽을 때 다른 내용 발견 가능

🔗 `READ_UNCOMMITTED` : 가장 빠른 격리 수준
- 가장 낮은 격리 수준
- 하나의 트랜잭션이 커밋되기 이전에 **다른 트랜잭션에 노출**되는 문제가 있음
- 거대한 양의 데이터를 '어림잡아' 집계하는 데 사용하면 좋음


💡 **격리 수준에 따라 발생하는 현상**

🔗 `팬텀 리드 (phantom read)` 
한 트랜잭션 내에서 **동일한 쿼리**를 보냈을 때 해당 조회 결과가 다른 경우

🔗 `반복 가능하지 않은 조회 (non-repeatable read)` 
한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우
1. 현재 A의 잔고가 100원일 때,
2. 은행원1이 A의 잔고를 조회했는데,
3. 그 이후 은행원2가 그 값을 1원으로 변경해서 커밋하면
4. 은행원1은 100원이 아닌 1원을 읽게됩니다.

🔗 `더티 리드 (dirty read)` 
한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 `커밋되지 않은` 행의 데이터를 읽을 수 있을 때 발생
1. 은행원1이 A의 잔고를 100원에서 1원으로 수정했는데 아직 커밋을 하지 않았을 때,
2. 은행원2는 A의 잔고를 1원 이라고 조회함


#### 4) 지속성 (Durability)
성공적으로 수행된 트랜잭션은 영구적이여야 한다. 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공한다.
- 체크섬: 중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법.
- 저널링: 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것.
- 롤백

### 무결성
데이터의 정확성, 일관성, 유효성을 유지하는 것이며, 무결성이 유지되어야 데이터 값과 실제의 값이 일치하는지에 대한 신뢰가 생긴다.
#### 종류

|이름|설명|
|---|---|
|개체 무결성|기본키로 선택된 필드는 빈 값을 허용하지 않음|
|참조 무결성|서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야함|
|고유 무결성|특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐|
|NULL 무결성|특정 속성 값에 NULL이 나올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건|

---
## 데이터베이스의 종류
### 관계형 데이터베이스

#### MySQL
대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스

- C, C++로 만들어짐
- MyISAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개 인덱스 제공
- 대용량 데이터베이스를 위해 설계
- 롤백, 커밋, 이중 암포 지원 보안 등의 기능 제공

🔗 MySQL **스토리지 엔진 아키텍처**
![[IMG-20250609200604571.png]]

**스토리지 엔진 : 데이터베이스의 심장 역할**
- 모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있으며, 데이터 웨어 하우징, 트랜잭션 처리, 고가용성 처리에 강점
- 스토리지 엔진 위에 커넥터 API 및 서비스 계층을 통해 MySQL 데이터베이스와 쉽게 상호 작용
- 쿼리 캐시를 지원해 입력된 쿼리 문에 대한 전체 결과 집합을 저장하기 때문에 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시

#### PostgreSQL
MySQL 다음으로 개발자들이 선호하는 데이터베이스 기술

- VACUUM : 디스크 조각이 차지하는 영역을 회수할 수 있음
- 최대 테이블 크기 : 32TB
- SQL 뿐만 아니라 JSON 이용해 데이터에 접근 가능
- 지정 시간 복구 기능, 로킹, 접근 제어, 중첩된 트랜잭션, 백업 등

### NoSQL
SQL을 사용하지 않는 데이터베이스

- 전통적인 RDBMS와 다른 DBMS를 지칭하기 위한 용어로 데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인 연산 사용 불가능
- 수평적으로 확장 가능
- ex) MongoDB, redis 등

#### MongoDB
⭐️ **JSON**을 통해 데이터 접근 가능하며 **Binary JSON 형태(BSON)**로 데이터가 저장

- 와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스
- 확장성과 빅데이터 저장할 때 성능이 좋다
- 고가용성, 샤딩, 레플리카셋 지원
- 스키마를 정해 놓지 않고 데이터를 삽입할 수 있어 다양한 도메인의 데이터베이스를 기반으로 분석하거나 로깅 등을 구현할 때 강점
- 도큐먼트를 생성할 때마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값인 `ObjectID`가 생성
    - 기본키로 유닉스 시간 기반의 타임스탬프(4바이트), 랜덤 값(5바이트), 카운터(3바이트)로 이루어짐

#### redis
⭐️ **인메모리** 데이터베이스이자 **키-값 데이터 모델 기반**의 데이터베이스

- 기본적인 데이터 타입 : 문자열(string)
- 최대 512MB까지 저장
- 이 외에도 셋(set), 해시(hash) 등 지원
- pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋(sorted set) 자료 구조를 이용한 실시한 순위표 서비스에 사용

---
## 인덱스
### [[인덱스(B-Tree, B+Tree)|B-Tree]]
![[IMG-20250609200604698.png|500]]
#### 인덱스가 효율적인 이유
효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 **균형 잡인 트리 구조**와 **트리 깊이의 대수확장성** 때문이다.

`대수확장성` : 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미
![[IMG-20250609200604810.png|150]]


### 인덱스 최적화 기법
#### 1. 인덱스는 **비용**이다.
👉 인덱스는 두 번 탐색하도록 강요
- 인덱스 리스트, 컬렉션 순으로 탐색하기 때문에 관련 읽기 비용이 듦
- 컬렉션이 수정되었을 때 인덱스도 수정되어야 함

❗️ 따라서 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아님
- 컬렉션에서 가져와야 하는 양이 많을수록 인덱스 사용이 비효율적이 됨

#### 2. 항상 **테스팅**하라.
👉 인덱스 최적화 기법은 서비스에서 사용하는 객체의 깊이, 테이블의 양 등에 따라 달라지므로 항상 테스팅 필요

- `explain()` 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간 최소화해야 함

```sql
EXPLAIN
SELECT * FROM t1
JOIN t2 ON t1.c1 = t2.c1
```

#### 3. 복합 인덱스는 **같음**, **정렬**, **다중 값**, **카디널리티** 순이다.
👉 보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스 생성 순서에 따라 성능이 달라짐

1. 어떠한 값과 같음을 비교하는 `==`이나 `equal`이라는 쿼리가 있다면 제일 먼저 인덱스로 설정
2. 정렬에 쓰는 필드라면 그다음 인덱스로 설정
3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스 설정
4. 유니크한 값의 정도 : 카디널리티. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다.예를 들어 age와 email이 있을 때, email이 더 높다. 즉 email이라는 필드에 대한 인덱스를 먼저 생성해야 함

---
## 조인의 원리
### 중첩 루프 조인
중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법
랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않음

🔗 의사 코드 예시
```sql
for each row in t1 matching reference key {
    for each row in t2 matching reference key { 
        if row satisfies join conditions, send to client 
    }
}
```

⭐️ 중첩 루프 조인에서 발전한 **블록 중첩 루프 조인(BNL, Block Nested Loop)** 방식도 있음
- 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인

### 정렬 병합 조인
각각의 테이블을 **조인할 필드 기준으로 정렬**하고, 정렬이 끝난 이후에 조인 작업을 수행하는 조인

- 조인할 때 쓸 적절한 인덱스가 없을 때
- 대용량의 테이블을 조인할 때
- 조인 조건으로 < , > 등 범위 비교 연산자가 있을 때

### 해시 조인
해시 테이블을 기반으로 조인하는 방법

- 하나의 테이블이 메모리에 온전히 들어간다면 보통 **중첩 루프 조인**보다 더 효율적임
- 동등(=) 조건에서만 사용 가능

❗️ MySQL의 해시 조인 단계는 **빌드 단계**, **프로브 단계**로 나뉨

#### 빌드 단계
![[IMG-20250609200604927.png|400]]
입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
- 바이트가 더 작은 테이블을 기반으로 해서 테이블을 빌드
- 조인에 사용되는 필드가 **해시 테이블의 키**로 사용됨

#### 프로브 단계
![[IMG-20250609200605066.png|500]]
레코드 읽기를 시작하며, 각 레코드에서 특정 값에 일치하는 레코드를 찾아서 결과값으로 반환하는 단계

> 이를 통해 각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋다. 참고로 사용 가능한 메모리양은 시스템 변수 `join_buffer_size` 에 의해 제어되며, 런타임 시에 조정할 수 있다.


참고
https://velog.io/@gkqls813/%EB%A9%B4%EC%A0%91%EC%9D%84-%EC%9C%84%ED%95%9C-CS-%EC%A0%84%EA%B3%B5%EC%A7%80%EC%8B%9D-%EB%85%B8%ED%8A%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EC%9D%B8%EB%8D%B1%EC%8A%A4