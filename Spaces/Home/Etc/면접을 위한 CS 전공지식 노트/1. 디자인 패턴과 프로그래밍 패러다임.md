## 목차
1. 싱글톤 패턴
2. 팩토리 패턴
3. 전략 패턴
4. 옵저버 패턴
5. 프록시 패턴과 프록시 서버
6. 이터레이터 패턴
7. 노출모듈 패턴
8. MVC 패턴
9. MVP 패턴
10. MVVM 패턴

## 디자인 패턴이란?
: 기존 환경 내에서 반복적으로 일어나는 문제들을 어떻게 풀어나갈 것인가에 대한 일종의 솔루션

- 설계할 때 발생했던 문제점들을 객체 간의 상호관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어놓은 것
- GoF의 디자인 패턴에서는 객체지향적 디자인 패턴을 3가지로 분류함
    - 생성 패턴 (Creational Pattern)
    - 구조 패턴 (Structural Pattern)
    - 행동 패턴 (Behavioral Pattern)

![[IMG-20250617170328269.png]]


## 1. 생성 패턴
: 객체의 생성에 관련된 패턴으로, 객체의 생성절차를 추상화하는 패턴
- 인스턴스를 만드는 절차를 추상화하는 패턴
- 시스템으로부터 객체의 생성/합성 방법을 분리해내기 위함

### 생성패턴의 특징
-  시스템이 어떤 구체 클래스를 사용하는지, 인스턴스들이 어떻게 만들어지고 합성되는지에 대한 정보를 캡슐화함
- "무엇", "어떻게", "언제", "누가" 생성하는지 알 필요가 없음

### 1-1. [[6. 스프링이 사랑한 디자인 패턴#싱글턴 패턴(Singleton Pattern)|싱글톤 패턴(Singleton Pattern)]]
: 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
- 하나의 인스턴스를 만들어놓고 다른 모듈들이 공유하여 사용
- 생성자가 여러 번 호출되어도 하나의 객체만 생성됨
- 인스턴스 생성 비용이 감소되며, 스프링 컨테이너 또한 이를 기반으로 함

> 💡 모듈 간 결합을 줄이기 위해 의존성 주입(Dependency Injection)을 활용할 수 있음
    
#### 사용 예시
- 보통 데이터베이스 연결 모듈(DBCP, DataBase Connection Pool)에 많이 사용함 (DB 연결 과정이 부하가 크고, 한 번 연결된 객체를 계속 사용해야 하기 때문)
- 스프링 컨테이너도 객체를 싱글톤으로 관리함

#### Java에서의 싱글톤 구현
[[싱글톤 패턴은 thread safe하지 않다?(개선 방식 4가지)]]

#### 문제점
- 객체지향 프로그래밍의 핵심인 **상속**과 **다형성**을 해친다.
- 객체지향 프로그래밍의 또 다른 핵심인 **정보 은닉**을 해친다. 공유의 목적으로 생성된 클래스이기 때문에, 객체를 요청하는 메소드를 public으로 강제할 수밖에 없다.
- Java의 고정적 싱글턴 패턴은 객체가 하나인 것을 보장할 수 없다.

> 💡 **싱글턴 패턴을 사용할 땐 조심하자!**
> 즉, 싱글턴 패턴은 굉장히 많이 활용되는 패턴이나, 앞서 말한 객체지향 프로그래밍의 기본 사상들을 많이 침해하기 때문에 굉장히 비판을 많이 받는 디자인 패턴이다.
> 따라서 싱글턴 패턴은 사용 시 매우 조심해서 사용해야 한다.
> 그것이 아니라면 위의 고전적인 싱글턴 패턴이 아닌 개선된 방식으로 객체의 싱글턴 방식을 구현하여 사용해야 한다.

#### 장단점
- 장점
    - 인스턴스를 생성할 때 드는 비용이 줄어든다
    - 최초 한번의 new 연산자를 통해서 고정된 메모리 영역을 사용하기 때문에 추후 해당 객체에 접근할 때 메모리 낭비를 방지할 수 있다
    - 다른 클래스간 **데이터 공유**가 쉽다
    
    > 전역으로 사용되는 인스턴스 이기에, 다른 클래스의 인스턴스들이 접근하여 사용 가능
    
- 단점
    - 모듈간의 결합이 강해진다(의존성이 높아진다)
    - 구체화 클래스에 의존도가 높아진다 -> DIP를 위반 -> OCP원칙을 위반할 수 있다
    - 싱글톤 패턴을 구현하는 코드 자체가 많이 필요하다
    - 자원을 공유하고 있기에 **테스트** 하기 어렵다 -> 격리된 환경에서 테스트가 수행될 수 있게 매번 인스턴스 상태를 초기화 필요


### 1-2. 팩토리 패턴 (Factory Pattern)
: 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
(객체 생성을 대신 수행해주는 공장!)
- 상위 클래스는 뼈대를 제공하고 하위 클래스가 생성 방식 정의
- 느슨한 결합으로 유연한 확장이 가능함

#### 장단점
- 장점 :
    - 객체 생성부를 캡슐화하여, 객체 간의 결합도를 낮출 수 있다 (느슨한 결합->구현체 클래스에 의존하지 않음)
    - OCP (개방 폐쇄 원칙)를 따른다
        - 클래스 내부 코드를 직접 수정하지 않아도 기능 확장/변경이 가능
    - SRP (단일 책임 원칙)를 따른다
        - 클라이언트가 특정 객체의 생성을 직접 생성하지 않고 생성 역할을 하는 클래스를 만들어 그 클래스에게 위임
- 단점 :
    - 새로 생성할 객체가 늘어날 때마다, Factory 클래스에 추가해야 되기 때문에 클래스가 많아진다

#### 종류
- [[6. 스프링이 사랑한 디자인 패턴#팩터리 메서드 패턴(Factory Method Pattern)|팩토리 메서드 패턴]]: 객체 생성을 서브클래스에 위임
- **추상 팩토리 패턴** : 관련 객체 집합 생성을 인터페이스로 추상화



## 2. 구조 패턴
### 2-1. [[6. 스프링이 사랑한 디자인 패턴#프록시 패턴(Proxy Pattern)|프록시 패턴 (Proxy Pattern)]]
: 대상 객체 접근 전 프록시 객체를 두어 제어하는 패턴
- 보안, 검증, 캐싱, 로깅 등에 사용
- 프록시 객체 혹은 프록시 서버로 구현 가능

#### 프록시 객체
: 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체를 뜻함
- **`target`** : 실제 대상 객체
- **`handler`** :  target 동작을 가로채서 정의할 동작들이 정해져 있는 함수

#### [[프록시(Proxy) 서버란?|프록시 서버]]
: 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 `서버와 클라이언트 사이 중계 시스템`

#### 장단점
- 장점 :
    - 사이즈가 큰 객체가 로딩되기 전에도 프록시를 통해 참조를 할 수 있다(전처리 및 후처리 사용 용이)
    - 특정 메서드에 대한 보안이 좋다. (B가 C에게 요청을 하여 A는 C가 무슨 일이 일어나는지 정확히 알기 힘들다는 점)
- 단점 :
    - 가독성이 떨어진다. (A->B->C라는 구조로 누군가 거쳐가야 한다는 점 이런 경우가 많아지면 가독성이 떨어질 우려된다)


## 3. 행동 패턴
### 3-1. [[6. 스프링이 사랑한 디자인 패턴#전략 패턴（Strategy Pattern )|전략 패턴(Strategy Pattern)]]
: 행위를 캡슐화하여 동적으로 행위 변경이 가능하도록 하는 패턴
- 정책 패턴이라고도 함
- 다양한 전략 객체를 정의하고 런타임에 교체 가능

#### 장단점
- 장점 :
    - 팩토리 패턴과 유사하게 공통 로직이 부모 클래스에 있지 않고 Context 라는 별도의 클래스에 존재하기 때문에 구현체들에 대한 영향도가 적음
    - 쉽게 변하지 않는 상위 인터페이스(클래스)에 의존하기 때문에 확장/삭제에 용이하다
- 단점 :
    - 로직이 늘어날 때 마다 구현체 클래스가 늘어난다
    - 앱에 들어가는 모든 전략을 알고 있어야 해서, 한번 전략을 조립하면 변경하기가 힘들다


### 3-2. 옵저버 패턴 (Observer Pattern)
![[Pasted image 20250617172059.png|400]]
: 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴
- 이벤트 기반 시스템에 사용하며, MVC(Model-View-Controller) 패턴에활용됨
	- **MVC 패턴** : Model(=주체)에서 변경 사항이 생겨 update() 메서드로 View(=옵저버)에 알려주고, 이를 기반으로 Controller가 작동함
- `주체` : 객체의 상태 변화를 보고 있는 관찰자
- `옵저버` : 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 '추가 변화 사항'이 생기는 객체들

#### 장단점
- 장점 :
    - 변경 사항이 생겨도 무난히 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있다
    - OCP (개방 폐쇄 원칙)를 지킬 수 있다
- 단점 :
    - 알림이 가는 순서를 보장할 수 없다
    - 옵저버와 알림을 받는 Subject간의 관계가 잘 정의되지 않으면 원치 않는 동작이 발생할 확률이 높다


### 3-3. 이터레이터 패턴
- 각기 다른 자료구조 구현체(array,linkedList,set)가 `iterator`라는 하나의 인터페이스를 통해 순회할 수 있도록 해주는 디자인 패턴
- 컬렉션을 노출하지 않고 순회 가능한 인터페이스 제공 패턴

#### 장단점
- 장점 :
    - 내부적인 구현 방법을 외부로 노출시키지 않으면서도 집합체에 있는 모든 항목에 일일이 접근할 수 있다
- 단점 :
    - 간단한 컬랙션인 경우, 이터레이터를 사용하는 것은 일부 특수 컬렉션의 요소를 직접 탐색하는 것 보다 덜 효율적일 수 있다


## 4. 기타 패턴
### 4-1. 노출모듈 패턴
- 즉시 실행 함수를 사용해 접근 제어자를 만드는 자바스크립트 패턴
- private/public 영역을 구분

### 4-2. MVC 패턴
: Model, View, Controller로 분리하여 구성 요소별 역할을 분리한 아키텍처 패턴
- 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있다.

#### 구성 요소
- Model: 데이터와 상태 관리
- View: 사용자 인터페이스 요소 표현
- Controller: 로직 처리, 뷰-모델 연결 역할

#### 장단점
- 장점 :
    - 서로 분리되어 각각의 역할만 담당함으로써 유지보수,확장성,유연성이 증가됨
    - 중복 코딩이라는 문제점 또한 사라진다
- 단점 :
    - View와 Model 사이의 의존성이 높다 -> 어플리케이션이 커질수록 복잡해지고 유지 보수가 어렵다


### 4-3. MVP 패턴
![[Pasted image 20250617173153.png|400]]
: MVC의 Controller를 Presenter로 대체한 구조
- 뷰와 프레젠트는 일대 일 관계이기 때문에 MVC패턴보다 더 강한 결합을 가지고 있음

#### Presenter
- View에서 요청한 정보로 Model을 가공하여 View에 전달해 주는 부분. View와 Model을 붙여주는 접착제 역할을 한다(컨트롤러와 유사)
- Presenter는 기존 MVC 패턴의 단점이었던 Model과 View 사이의 **높은 의존성**을 해소하기 위하여 등장

#### 장단점
- 장점 :
    - View와 Model 사이에 Presenter라는 연결 부분을 두어 MVC 패턴의 단점인 의존성을 보완했다
        - MVC 패턴의 단점인 View와 Model사이의 의존성이 없다
- 단점 :
    - View와 Presenter사이는 1대1관계를 유지해야해서 의존성이 높고, 앱이 커질수록 이 의존성은 더 강해진다


### 4-4. MVVM 패턴
![[Pasted image 20250617173242.png|500]]
: ViewModel을 사용하는 구조로 양방향 데이터 바인딩 지원
- MVVM은 View와 ViewModel사이의 관계가 1대N으로 되어있다

#### View Model(VM)
- View Model은 View를 더 추상화한 계층
- View 상태를 유지 및 변화시키고, View에 대한 작업의 결과로 Model을 조작한다
- View에서 발생되는 이벤트를 전달 하는데 도움이 되는 메서드, 명령, 또는 다른 속성들을 노출하는 역할을 한다

#### 장단점
- 장점 :
    - View와 View Model 사이 양방향 데이터 바인딩을 지원한다
    - View와 Model 사이의 의존성이 없다. View와 View Model 사이의 의존성이 없다
    - UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다
- 단점 :
    - View Model의 설계가 어려움

> 💡 **데이터 바인딩이란?**
>  데이터 바인딩이란 View와 메모리상의 데이터를 동기화하는 기술로 뷰 모델을 변경하면 뷰가 변경된다.

#### MVVM 패턴의 대표적인 예 : Vue.js
- Vue.js : 반응형이 특징인 프론트 프레임워크
- Watch, computed등을 통해 쉽게 반응형적인 값을 구축할 수 있음
- 함수를 사용하지 않고 값 대입만으로 변수가 변경되며 양방향 바인딩, html을 토대로 컴포넌트를 구축할 수 있다는 점이 특징, 재사용 가능한 컴포넌트 기반으로 UI를 구축할 수 있음

#### 동작 순서
1. 사용자가 View를 통해 Action 발생
    
2. Action이 ViewModel로 전달됨
    
3. ViewModel이 Model에 데이터 요청
    
4. Model이 응답
    
5. ViewModel이 데이터를 가공 후 저장
    
6. View가 ViewModel을 통해 렌더링



참고
[디자인 패턴과 프로그래밍 패러다임(1)_이홍섭.md](https://github.com/hongxeob/CS-Study/blob/main/1.%20%EB%94%94%EC%9E%90%EC%9D%B8%20%ED%8C%A8%ED%84%B4%EA%B3%BC%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84(1)/1.%20%EB%94%94%EC%9E%90%EC%9D%B8%20%ED%8C%A8%ED%84%B4%EA%B3%BC%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84(1)_%EC%86%A1%EB%AF%BC%EC%A7%84.md)
[면접을 위한 CS 전공지식노트(1) - 디자인 패턴](https://velog.io/@onebbu/%EB%A9%B4%EC%A0%91%EC%9D%84-%EC%9C%84%ED%95%9C-CS-%EC%A0%84%EA%B3%B5%EC%A7%80%EC%8B%9D%EB%85%B8%ED%8A%B81-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4)
[면접을 위한 CS 전공 지식 노트 - 1. 디자인패턴](https://security-gom.tistory.com/56)