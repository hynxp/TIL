자료 구조는 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합이다.

## 복잡도
복잡도는 시간 복잡도와 공간 복잡도로 나뉜다.

### 시간 복잡도
시간 복잡도는 `입력 크기(n)에 따라 알고리즘이 실행되는 데 걸리는 시간`을 나타내며, 주로 Big-O 표기법을 사용한다.

**시간 복잡도가 중요한 이유는 효율적인 코드로 개선하는 게 쓰이는 척도가 되기 때문이다.**

#### 빅오 표기법
| 표기         | 의미    | 예시             |
| ---------- | ----- | -------------- |
| O(1)       | 상수 시간 | 배열 인덱스 접근      |
| O(log n)   | 로그 시간 | 이진 탐색          |
| O(n)       | 선형 시간 | 배열 전체 순회       |
| O(n log n) | 로그 선형 | 병합 정렬, 퀵 정렬 평균 |
| O(n²)      | 이차 시간 | 중첩 반복문         |
입력 범위 n을 기준으로 로직이 몇 번 반복되는지 나타내는 것이다. 입력 크기가 커질수록 가장 많이 커지는 항은 n의 제곱합이기 때문에 이것만 신경쓰면 된다는 이론이다.

아래 코드는 시간 복잡도가 10n^2+n인데, 빅오 표기법으로 나타내면 O(n^2)이 됨
-> '가장 영향을 많이 끼치는'항의 상수 인자를 빼고 나머지 항을 없앤 것
```java
for(int i=0 ; i<10 ; i++) {
	for(int j=0 ; j<n ; j++) {
		for(int k=0 ; k<n ; k++) {
			cout << k << '\n';
		}
	}
}
for(int k=0 ; k<n ; k++) {
    cout << k << '\n';
}
```

### 공간 복잡도
`프로그램을 실행시켰을 때 필요로 하는 자원의 양`이다. 
정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함한다.

| 용어     | 설명                |
| ------ | ----------------- |
| 정적 메모리 | 배열, 전역 변수 등       |
| 동적 메모리 | 재귀 호출 스택, 동적 할당 등 |
예를 들어, 피보나치 수열을 배열에 저장하는 경우 공간 복잡도는 O(n)이지만, 두 변수만 사용하면 O(1)로 줄일 수 있다.

### 자료 구조에서 시간 복잡도
![[Pasted image 20250613002917.png]]

## 선형 자료 구조
요소가 일렬로 나열되어 있는 자료 구조를 말한다.

### 연결 리스트
![[IMG_8D8BB6CF767C-1.jpeg|500]]
데이터를 감싼 노드를 포인터로 연결해 공간 효율성을 극대화한 자료 구조이다. 
맨 처음 노드가 head, 특정 노드의 다음 노드를 가리키는 next 포인터, 이전 노드를 가리키는 prev 포인터가 있다.

|종류|특징|
|---|---|
|단일 연결 리스트|다음 노드만 참조|
|이중 연결 리스트|이전, 다음 모두 참조|
|원형 연결 리스트|마지막 노드가 head 참조|

### 배열
같은 타입의 변수로 이루어져 있고 크기가 정해져 있으며 인접한 메모리 위치에 데이터를 모아 놓은 집합이다. 
- 탐색에 `O(1)`, 삽입과 삭제는 `O(n)`이 걸림
- 따라서 추가와 삭제를 많이 한다면 연결리스트를, 탐색을 많이 한다면 배열로 하는 것이 좋음
- 배열은 모든 요소를 앞으로 옮겨야 삽입이 가능하여 `O(n)`이 걸리지만, 연결리스트는 포인터를 바꿔서 연결만 하면 되어서 `O(1)`로 가능함

#### 랜덤 접근과 순차 접근
`직접 접근`이라고 하는 `랜덤 접근`은 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근하는 것이다.
`순차 접근`은 데이터를 저장된 순서대로 검색해야 하는 것이다.

### 벡터(동적 배열)
동적으로 요소를 할당할 수 있는 동적 배열이다. 
컴파일 시점 개수를 모른다면 벡터를 써야 한다. 탐색, 맨 뒤 요소 삭제 및 삽입에 `O(1)`, 맨 뒤나 맨 앞의 요소가 아닌 요소를 삭제 및 삽입하는 데 `O(n)`의 시간이 걸린다.

### 스택
가장 마지막으로 들어간 데이터가 가장 첫번째로 나오는 LIFO(Last In, First Out) 성질을 가진 자료 구조이다. 삽입 및 삭제에 `O(1)`, 탐색에 `O(n)`이 걸린다.
재귀 함수, 웹 브라우저 방문 기록 등에 사용된다.

### 큐
먼저 집어 넣은 데이터가 먼저 나오는 FIFO 성질을 가진 자료구조이다. 삽입 및 삭제에 O(1), 탐색에 `O(n)`이 걸린다.
CPU 작업을 기다리는 프로세스, BFS, 스레드 행렬 등에 사용된다.


## 비선형 자료 구조
일렬로 나열되지 않고 자료 순서나 관계가 복잡한 구조를 말한다. 일반적으로 트리, 그래프를 말한다.

### 그래프
정점(vertec)과 간선(edge)으로 이루어진 자료 구조이다.

짝사랑은 단방향 간선... 쌍방이면..양방향 간선ㅋ

| 용어         | 설명               |
| ---------- | ---------------- |
| 인접 리스트     | 간선 정보를 리스트로 표현   |
| 인접 행렬      | 2차원 배열로 표현       |
| out-degree | 나가는 간선 수         |
| in-degree  | 들어오는 간선 수        |
| 가중치        | 정점과 간선 사이에 드는 비용 |

### 트리
그래프 중 하나로, 트리 구조로 배열된 일종의 계층적 데이터 집합이다. 
루트 노드, 내부 노드, 리프 노드 등으로 이루어지며 루트 노드는 맨 상위의 부모 노드, 내부 노드는 리프 노드와 루트 사이의 노드, 리프 노드는 자식이 없는 노드를 의미한다.

아래의 특징을 갖는다.

![[Pasted image 20250613004556.png|400]]
1. 부모 자식 계층 구조를 갖는다.
2. V(노드 수) - 1 = E(간선 수)라는 특징이 있다.
3. 임의의 두 노드 사이의 경로는 반드시 존재한다.

#### 트리의 높이와 레벨
![[Pasted image 20250613004626.png|400]]
- 깊이: 루트 노드로부터 특정 노드까지 최단 거리로 갔을 때의 거리. 4번 노드 깊이는 2이다.
- 높이: 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리. 그림에서는 3이다.
- 레벨: 높이와 비슷한 의미를 갖는데, 루트 노드 1번이 0레벨이라면 2,3은 1레벨, 1번이 1레벨이라면 2,3번은 2레벨이다.
- 서브트리: 트리 내 부분 집합이다. 5,6,7번 노드만 보면 서브트리이다.

#### 이진트리
자식의 노드 수가 2개 이하인 트리이다.
![[IMG_E1A7BA6293F5-1.jpeg]]
- 정이진 트리: 자식 노드가 0 or 2개인 이진 트리
- 완전 이진 트리: 왼쪽부터 채워진 이진 트리
- 변질 이진 트리: 자식 노드가 1개뿐인 이진 트리
- 포화 이진 트리: 모든 노드가 꽉 찬 이진 트리
- 균형 이진 트리: 왼쪽과 오른쪽 노드 높이 차이가 1 이하인 이진 트리

#### 이진 탐색 트리
- 노드의 오른쪽 하위 트리에는 노드 값보다 큰 값, 왼쪽 하위 트리에는 노드 값보다 작은 값이 들어 있는 트리
- 오른 쪽에는 큰 값, 왼쪽에는 작은 값만 있기 때문에 검색에 용이함
- 보통의 경우는 탐색, 삽입, 삭제 모두 O(logn)이지만 최악의 경우 O(n)이 걸림
- 하지만 이진 탐색 트리는 삽입 순서에 따라 선형적일 수 있기 때문에 최악의 경우 O(n)이 걸림
    - 예를 들어 정렬된 상태로 삽입된 경우 (5,4,3,2,1)

#### AVL 트리
- 최악의 경우 선형적인 트리가 되는 것을 방지하고, 스스로 균형을 잡는 이진 탐색 트리
- 오른쪽, 왼쪽 두 자식 서브트리의 높이 차이는 최대 1이다.
- 높이 차이가 1보다 커지면 회전을 통해 균형을 맞춰 높이 차이를 줄인다
- 탐색, 삽입, 삭제 모두 **O(logn)**, 삽입과 삭제를 할 때마다 균형을 맞추기 위해 트리의 일부를 왼쪽 혹은 오른쪽으로 회전시키며 균형을 잡음
    - Balance Factor를 활용해 균형이 무너졌는지를 판단함
    - BF(K) = K의 왼쪽 서브트리의 높이 - K의 오른쪽 서브트리의 높이
    - AVL트리의 모든 노드의 BF가 -1, 0, 1중 하나여야 한다. 이를 벗어나면 회전이 필요한 상태!

Right Rotation
![[Pasted image 20250613005010.png|400]]

Left Rotation
![[Pasted image 20250613005032.png|400]]

#### 레드 블랙 트리
- 균형 이진 탐색 트리로 탐색, 삭제, 삽입 모두 O(logn)
- 각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며, 삽입 및 삭제 중에 트리가 균형을 유지하도록 하는데 사용됨
- C++ STL의 set, multiset, map, multimap등이 레드 블랙 트리를 이용해 구현되어 있음

### 힙
- 완전 이진 트리 기반의 자료 구조
- 최대힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야 함. 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 함
- 최소힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 작아야 함. 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 함


**최대힙의 삽입과 삭제**
![[IMG_22A14123C5C6-1.jpeg|500]]
8이라는 값이 들어왔을 때 노드가 올라가면서 스왑하는 과정

- 삽입: 새로운 요소가 들어오면, 새로운 노드를 힙에 삽입한다. 부모 노드와의 크기를 비교하며 교환해서 성질을 만족시킨다.
- 삭제: 최댓값인 루트 노드가 삭제되며 마지막 노드와 루트 노드를 스왑하여 다시 재구성한다.

### 우선순위 큐
- 우선순위 대기열이라고도 하며, 대기열에서 우선순위가 높은 요소가 우선 순위가 낮은 요소보다 먼저 제공되는 자료 구조
- 힙을 기반으로 구현됨


### 맵
- 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조
- "알고리즘": 1, "운영체제": 2 와 같이 string: int 형태로 값을 할당해야 할 때
- 정렬을 보장하지 않는 unordered_map과 정렬을 보장하는 map 두 가지가 있음

### 셋
- 특정 순서에 따라 고유한 요소를 저장하는 컨테이너
- 중복되는 요소는 없고 오로지 unique한 값만 저장하는 자료구조

### 해시 테이블
- 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블
- 작은 크기의 캐시 메모리로도 프로세스를 관리하도록 할 수 있음
- 삽입, 삭제, 탐색 시 평균적으로 **O(1)**의 시간 복잡도를 가지며 unordered_map으로 구현함
- 각 key값에 해시 함수를 적용해 배열의 고유한 index를 생성하고, index를 활용해 값을 저장하거나 검색함
- 실제 값이 저장되는 장소를 버킷 또는 슬롯이라고 함
    - ("John Smith", "521-1234")인 데이터를 크기가 16인 해시 테이블에 저장한다.
    - index를 hash_function("John Smith") % 16 연산을 통해 index 값을 계산한다. 그리고 array[index]에 전화번호를 저장함
    - 해싱 구조로 데이터를 저장하면 key 값으로 데이터를 찾을 때 해시 함수를 한 번만 수행하면 되므로 매우 빠르게 데이터를 저장/삭제/조회할 수 있다.

![[Pasted image 20250613005335.png]]


참고
https://peachsoong.tistory.com/103
https://velog.io/@pswo1021/%EB%A9%B4%EC%A0%91%EC%9D%84-%EC%9C%84%ED%95%9C-CS-%EC%A0%84%EA%B3%B5%EC%A7%80%EC%8B%9D-%EB%85%B8%ED%8A%B85.-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0