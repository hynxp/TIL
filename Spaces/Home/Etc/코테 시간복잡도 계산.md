알고리즘 문제를 풀 때 목표로 해야 하는 시간 복잡도를 추측하는 방법은 주어진 입력 크기와 제한 시간을 분석하는 것이다. 이를 통해 어떤 알고리즘을 선택해야 하는지 가늠할 수 있다.


## 1. 입력 크기( N )에 따른 적절한 시간 복잡도
컴퓨터가 1초 동안 수행할 수 있는 연산 횟수는 일반적으로 약 10⁸ (1억) 개 정도이다. 이를 기준으로 하면 다음과 같은 추측이 가능하다.

|입력 크기 (N)|허용되는 시간 복잡도|
|---|---|
|N ≤ 10|O(N!) 가능 (완전탐색, 백트래킹)|
|N ≤ 20|O(2^N) 가능 (비트마스킹, DFS)|
|N ≤ 500|O(N³) 가능 (플로이드-워셜 같은 DP)|
|N ≤ 10,000|O(N²) 가능 (버블 정렬, DP)|
|N ≤ 100,000|O(N log N) 가능 (이분 탐색, 머지 정렬)|
|N ≤ 10,000,000|O(N) 가능 (그리디, 해시, 투 포인터)|
|N ≥ 100,000,000|O(log N) 또는 O(1) 필요 (이분 탐색, 수학적 접근)|

## 2. 제한 시간( T )을 활용한 대략적인 추측
보통 코딩 테스트에서 1초(혹은 2초) 제한이 주어진다.  
이를 통해 시간 복잡도를 역으로 추론할 수 있다.

- 1초당 10⁸ 연산 가능 →
    - O(N log N) 이하: N이 10⁶~10⁷이면 안전함
    - O(N²): N이 10³~10⁴ 이하일 때 가능
    - O(2^N): N이 20 이하일 때 가능

예를 들어, 문제에서 N = 100,000 이면 O(N²) 이상의 알고리즘은 시간 초과가 날 가능성이 크므로 O(N log N) 이하의 알고리즘을 찾아야 한다.



## 3. 문제 유형별 시간 복잡도 추측
어떤 유형의 문제인지에 따라 대략적인 시간 복잡도를 예상할 수 있다.

|문제 유형|일반적인 시간 복잡도|
|---|---|
|완전 탐색 (브루트포스)|O(N!) 또는 O(2^N)|
|정렬 문제|O(N log N)|
|그래프 탐색 (BFS, DFS)|O(V + E)|
|최단 경로 (다익스트라)|O(E log V)|
|다이나믹 프로그래밍 (DP)|O(N²) 또는 O(N³)|
|이분 탐색|O(log N)|
|해싱, 투 포인터|O(N)|
|세그먼트 트리|O(log N)|



## 4. 예제 문제를 통해 시간 복잡도 추측 연습
#### 예제 1: N ≤ 10⁵, 정렬 문제
- `N`이 100,000이라면 O(N log N) 이하로 풀어야 한다.
- 퀵 정렬(평균 O(N log N)), 병합 정렬, 힙 정렬을 고려.

#### 예제 2: N ≤ 100, 그래프 최단 경로 문제
- 100개 정점의 그래프에서 모든 정점 간 최단 거리를 구하는 문제라면?
- O(N³)의 플로이드-워셜 알고리즘(100³ = 1,000,000) 사용 가능.

#### 예제 3: N ≤ 10⁶, 배열에서 최댓값 구하기
- 단순 탐색 O(N) 사용 가능.

#### 예제 4: N ≤ 20, 부분집합 문제
- O(2^N) 가능 → 비트마스킹, 백트래킹 사용 가능.


## 5. 정리: 시간 복잡도 추측 프로세스
1. 입력 크기(N)를 확인한다.
2. 1초당 10⁸ 연산을 기준으로 적절한 복잡도를 판단한다.
3. 문제 유형(정렬, DP, 그래프, 탐색 등)을 파악한다.
4. 가능한 알고리즘을 후보군으로 정한다.
5. 구현 전에 시간 초과 여부를 대략적으로 검토한다.