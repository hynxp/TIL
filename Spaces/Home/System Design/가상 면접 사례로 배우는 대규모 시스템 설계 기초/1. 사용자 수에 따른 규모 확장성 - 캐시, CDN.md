
## 캐시
웹 계층과 데이터 계층을 넘어, 시스템의 응답 시간(latency)을 개선하려면 **캐시**를 도입하는 것이 중요하다.
응답 시간은 `캐시(cache)`를 붙이고 정적 컨텐츠를 `콘텐츠 전송 네트워크(CDN)`로 옮기면 개선할 수 있다.

캐시는 `값비싼 연산 결과` 또는 `자주 참조되는 데이터`를 메모리 보관해,  뒤이은 요청을 더 빠르게 처리할 수 있도록 돕는 저장소이다.

![[IMG-20250830182235439.png]]
위 설계에서는, 사용자가 웹 페이지를 새로고침할 때마다 데이터를 가져오기 위해 데이터베이스를 계속 호출한다. 
애플리케이션의 성능은 **데이터베이스를 얼마나 자주 호출하느냐**에 크게 좌우되는데, **캐시**는 그런 문제를 완화할 수 있다.

### 캐시 계층(cache tier)
캐시 계층은 데이터가 잠시 보관되는 곳으로, 데이터베이스보다 훨씬 빠르다.
별도의 캐시 계층을 두면 성능이 개선될 뿐만 아니라 데이터베이스의 부하를 줄이고, 캐시만 독립적으로 확장시키는 것도 가능하다.

#### 캐싱 전략
캐시 서버를 두었을 때 일반적인 처리 흐름은 다음과 같다.
![[IMG-20250830182235532.png|500]]

1. 웹 서버는 우선 캐시에 데이터가 있는지 검사한다.
2. 데이터가 캐시에 있다면 해당 데이터를 클라이언트에 바로 반환한다.
3. 데이터가 없다면 데이터베이스에서 조회한 뒤 캐시에 저장하고 클라이언트에 반환한다.

> 이러한 캐시 전략을 캐시 우선 읽기 전략(read-through caching strategy)라고 한다.

#### 다양한 캐시 전략

| **전략 이름**     | **설명**                    |
| ------------- | ------------------------- |
| Cache Aside   | 애플리케이션이 캐시를 직접 관리         |
| Read-Through  | 캐시 서버가 데이터 저장소에서 읽어와 캐싱   |
| Write-Through | 쓰기 연산 시 캐시와 저장소에 동시에 반영   |
| Write-Around  | 쓰기 연산 시 캐시는 건너뛰고 저장소에만 쓰기 |

이외에도 `Cache Aside`, `Read-Through`, `Write-Through`, `Write-Around` 등 다양한 전략이 있으며, **캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택**하면 된다. 

### 캐시 사용 시 유의할 점
캐시를 사용할 때는 아래 사항들을 고려하여야 한다.

> 어떤 상황에 바람직한가?

데이터 갱신은 자주 일어나지 않지만, 참조는 자주 일어나는 경우 캐시 사용이 적합하다.

> 어떤 데이터를 캐시에 둘까?

캐시는 휘발성 메모리 기반이므로, 영속적으로 보관해야 할 중요 데이터는 캐시에 두면 안 된다.
예를 들어, 캐시 서버가 재시작되면 캐시 내의 모든 데이터는 사라진다. 

> 데이터 만료(expire)는 어떻게 관리할까?

**만료된 데이터는 캐시에서 삭제되어야 한다.** 
만료 정책이 없으면 데이터는 캐시에 계속 남게 된다. 그치만 **만료 기한이 너무 짧으면 데이터베이스를 너무 자주 읽게 되므로** 좋지 않고, **너무 길어도 원본과 차이가 날 가능성이 높아지기 때문에** 적절한 만료 기간을 설정해야 한다.

> 일관성(consistency)은 어떻게 유지할까?

일관성은 **데이터 저장소의 원본과 캐시 내의 사본이 같은지 여부**다. 
저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 이 일관성은 깨질 수 있다. 여러 지역에 걸쳐 시스템을 확장해 나가는 경우 캐시와 저장소 사이의 일관성을 유지하는 것은 어려운 문제가 된다.

> 장애에 어떻게 대응할까?

캐시 서버를 한 대만 두면 해당 서버는 `단일 장애 지점(Single Point of Failure, SPOF)`이 된다. 
![[IMG-20250830182236028.png|300]]

결과적으로 **SPOF를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산**시켜야 한다.

> 캐시 메모리는 얼마나 크게 잡을 것인가?

`너무 작으면` 데이터가 자주 밀려나(eviction) 캐시 효율이 떨어지고, 너무 크면 과도한 리소스를 사용하게 된다.
캐시 메모리를 `과할당(overprovision)`하면 캐시에 보관될 데이터가 갑자기 늘어났을 때 생길 문제도 방지할 수 있다.

> 데이터 방출(eviction) 정책은 무엇을 쓸까?

캐시가 꽉 차버리면 추가로 캐시에 데이터를 넣어야 할 경우 기존 데이터를 내보내야 한다. 이것을 `캐시 데이터 방출 정책`**이라고 한다.

그 가운데 가장 널리 쓰이는 것은 아래 정책들이 있으며, 경우에 맞게 적용하면 된다.

|**방출 정책**|**설명**|
|---|---|
|LRU (Least Recently Used)|마지막으로 사용된 시점이 가장 오래된 데이터를 내보냄|
|LFU (Least Frequently Used)|사용 빈도가 가장 낮은 데이터를 내보냄|
|FIFO (First In First Out)|가장 먼저 들어온 데이터를 가장 먼저 내보냄|


## CDN(콘텐츠 전송 네트워크)
CDN은 지리적으로 분산된 서버 네트워크로, 이미지, 비디오, CSS, JavaScript 같은 정적 콘텐츠를 빠르게 전송하는 데 사용된다.

> `동적 콘텐츠 캐싱`은 상대적인 개념으로서, 요청 경로(request path), 질의 문자열(query string), 쿠키(cookie), 요청 헤더(request header) 등의 정보에 기반하여 HTML 페이지를 캐시하는 것이다.

### CDN 동작 방식
어떤 사용자가 웹사이트를 방문하면 그 **사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달**하게 된다. 사용자가 CDN 서버로부터 멀면 멀수록 웹사이트는 천천히 로드될 것이다.

![[IMG-20250830182236521.png|600]]
아래 그림은 CDN이 어떻게 동작하는지를 설명한다.
![[IMG-20250830182236917.png|500]]
1. 사용자 A가 이미지 URL을 이용해서 image.png에 접근한다.
- URL의 도메인은 CDN 서비스 사업자가 제공한다.
- 아래의 두 URL은 `클라우드프론트(CloudFront)`와 `아카마이(Akamai) CDN`이 제공하는 URL의 예제이다.
    - `https://mysite.cloudfront.net/logo.jpg`
    - `https://mysite.akamai.com/image-manager/img/logo.jpg`

2. CDN 서버의 캐시에 해당 이미지가 없는 경우, 서버는 원본(origin) 서버에 요청하여 파일을 가져온다.
원본 서버는 웹 서버일 수도 있고 아마존(Amazon) S3 같은 온라인 저장소일 수도 있다.

3. 원본 서버가 파일을 CDN 서버에 반환한다.
응답의 HTTP 헤더에는 해당 파일이 얼마나 오래 캐시될 수 있는지를 설명하는 `TTL(Time-To-Live)` 값이 들어 있다.

4. CDN 서버는 파일을 캐시하고 사용자 A에게 반환한다.
이미지는 TTL에 명시된 시간이 끝날 때까지 캐시된다.

5. 사용자 B가 같은 이미지에 대한 요청을 CDN 서버에 전송한다.

6. 만료되지 않은 이미지에 대한 요청은 캐시를 통해 처리된다.


### CDN 사용 시 고려해야 할 사항

1. 비용
- CDN은 제3 사업자가 운영하며, 데이터 전송량에 따라 요금이 부과된다. 자주 쓰이지 않는 콘텐츠는 CDN에서 빼는 것을 고려해야 한다.

2. 적절한 만료 시한 설정
- **`시의성이 중요한(time-sensitive)` 콘텐츠**의 경우 만료 시점을 잘 정해야 한다.
    - 너무 길면 콘텐츠의 신선도는 떨어진다.
    - 너무 짧으면 원본 서버에 빈번히 접속하게 되어서 좋지 않다.

> 시의성이 중요하다 - 시간에 민감한 정보들을 말한다.
> ex) 실시간 뉴스, 주식, 항공편 정보 등..

3. CDN 장애 대응
- **CDN 자체가 죽었을 경우 웹사이트/애플리케이션이 어떻게 동작해야 하는지 고려**해야 한다.
- 일시적으로 CDN이 응답하지 않을 경우, 해당 문제를 감지하여 원본 서버로부터 직접 콘텐츠를 가져오도록 클라이언트를 구성하는 것이 필요할 수도 있다.

4. 콘텐츠 무효화(invalidation) 방법
- **아직 만료되지 않은 콘텐츠**라 하더라도 아래 방법 가운데 하나를 쓰면 **CDN에서 제거**할 수 있다.
    - CDN 서비스 사업자가 제공하는 API를 이용하여 콘텐츠 무효화
    - 콘텐츠의 다른 버전을 서비스하도록 `오브젝트 버저닝(object versioning)` 이용. 콘텐츠의 새로운 버전을 지정하기 위해서는 URL 마지막에 버전 번호를 인자로 주면 된다. (Ex. `image.png?v=2`)


### CDN과 캐시가 추가된 설계
![[IMG-20250830182236957.png]]
변화된 부분은 다음과 같다.
1. 정적 콘텐츠(JS, CSS, 이미지 등)는 더 이상 웹 서버를 통해 서비스하지 않으며, CDN를 통해 제공하여 더 나은 성능을 보장한다.
2. 캐시가 데이터베이스 부하를 줄여준다.

최종 설계는 아래와 같은 흐름으로 작동한다.

|**계층**|**역할**|
|---|---|
|CDN|정적 콘텐츠(JS, CSS, 이미지 등)를 캐싱하고 빠르게 전송|
|캐시|데이터베이스 질의 부담을 줄이고 응답 시간을 개선|
|데이터베이스|주-부 다중화를 통해 쓰기/읽기 작업 분리 및 안정성 확보|
|로드밸런서|웹 서버로의 트래픽을 분산하여 고가용성을 확보|
|웹 서버|클라이언트 요청 처리 및 캐시/데이터베이스 연동|
