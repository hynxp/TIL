## 인터페이스와 abstract를 사용하는 이유
인터페이스와 abstract 클래스에 대해서 제대로 이해하려면 시스템을 만드는 절차를 알아야 한다.
어떤 시스템을 개발하든 간에 “방법론”이라는 것을 사용하여 개발한다.

### 방법론 
시스템을 어떻게 만들 것인지에 대한 절차를 설명하고 어떤 산출물을 작성해야 하는지를 정리해 놓은 공동 절차

**방법론의 일반적인 절차**
- 분석
    - 요구사항 분석
- 설계
    - 어떤 메소드를 만들 것인지, 데이터는 어떻게 저장할지
- 개발 및 테스트
- 시스템 릴리즈

### 이게 인터페이스와 abstract랑 뭔 상관인데?
1. 설계 단계의 산출물을 문서에만 정리하면 나중에 메서드 관련 내용들이 변경되면 문서도 수정해야 하므로 2중 3중의 일이 된다.
	이 설계 단계에서 인터페이스라는 것을 만들어 두면 개발할 때 메서드의 이름을 어떻게 할지, 매개 변수를 어떻게 할지 일일이 고민하지 않아도 된다.
    
2. 선언과 구현을 구분할 수 있다.
    가장 일반적인것이 DAO 패턴이다.
    이 패턴은 데이터를 저장하는 저장소에서 원하는 값을 요청하고 응답을 받는다.
    이 세상에는 여러 가지 종류의 DBMS가 있기 때문에 회원 정보를 확인하는 MemberDAO라는 인터페이스를 만든다고 생각했을 때, 어떤 DBMS를 사용해도 상관 없도록 만들 것이다.

> [!NOTE] 정리
>-  설계시 선언해 두면 개발할 때 기능을 구현하는 데만 집중할 수 있다.
> - 개발자의 역량에 따른 메소드의 이름과 매개 변수 선언의 격차를 줄일 수 있다.
> - 공통적인 인터페이스와 abstract 클래스를 선언해 놓으면, 선언과 구현을 구분할 수 있다.

## 인터페이스 예제

```java
public interface MemberManage{}
public class MemberManageImpl implements MemberManage{}
```
인터페이스의 또 다른 용도는 외부에 노출되는 것을 정의해 놓고자 할 때 사용된다.

다시 말해서 MemberManager라는 클래스가 있는데, 이 클래스가 “저한테 직접 이야기하지 마시구요, 공식적인 것은 저의 대변인을 통해서 말씀하세요”라고 내놓는 대변인이 바로 인터페이스다.

만약 아래와 같이 컴파일하면 에러가 발생한다.
`MemberManage member = new MemberManage();`
컴파일러가 아무것도 구현해 놓지 않았는데, 왜 얘로 초기화하려는 것이냐?라며 에러를 내뿜는 것

`MemberManage member = new MemberManageImpl();`
이렇게 사용해야 한다.

## final
마지막이라는 뜻이다.
final은 클래스, 메소드, 변수에 선언할 수 있다.

### 클래스에서의 final
```java
public final class FinalClass {} 
```
클래스가 final로 선언되어 있으면 상속을 해 줄 수 없다.

**그럼 언제 final 클래스를 사용하나요?**
더 이상 확장해서는 안 되는 클래스, 누군가 이 클래스를 상속 받아서 내용을 변경해서는 안되는 클래스를 선언할 때 `final`로 선언하면 된다.
ex) `String`이라는 클래스는 자바에서 아주 중요한 클래스이며 이 클래스를 조금이라도 변경해서 사용하면 안 된다.
만약 `String`이 `final`클래스가 아니었다면 사용자가 `toString()`메서드를 상속받아 무조건 1이 리턴되게끔 변경할 수 있는것이다.

### 메서드에서의 final
메서드를 final로 선언하면 더 이상 오버라이딩할 수 없다.
잘 사용하지는 않지만 메서드를 누가 변경하지 못하도록 하려면 final 메서드로 선언하면 된다.

### 변수에서의 final
변수에 final을 사용하면 그 변수는 “더 이상 바꿀 수 없다.”라는 말이다.

**인스턴스 변수와 클래스 변수의 final**
인스턴수 변수나 static으로 선언된 클래스 변수는 선언과 함께 값을 지정(초기화)해야만 한다.
```java
public class TestClass {
	final int value; //컴파일 에러
	final int value = 1;
}
```
final 변수는 더 이상 바꿀 수 없으므로 값이 없는채로 변수를 사용할 수는 없으니 당연한 것이다.

**지역 변수와 매개 변수의 final**
매개 변수나 지역 변수를 final로 선언하는 경우에는 반드시 선언할 때 초기화할 필요는 없다.
```java
public void testMethod(**final** int parameter) {
	**final** int localVariable;
}
```

왜냐하면 매개 변수는 이미 초기화가 되어서 넘어 왔고, 지역 변수는 메소드 내에서만 참조되므로 다른 곳에서 변경할 일이 없다. 따라서 컴파일은 문제없이 된다.

하지만 아래와 같이 사용해서는 안 된다.
```java
public void testMethod(**final** int parameter) {
	**final** int localVariable;
	localVariable = 2;
	localVariable = 3;
	paramter = 4;
}
```
final 변수는 다시 값을 할당할 수 없기 때문이다.

### 그럼 final 변수는 왜 사용할까
1월과 12월이 31일까지 있다는 것은 누구나 알고 있다. 이 사실은 변하지 않는다.
1월에 대한 날짜수를 JANUARY_DATE라는 변수에 31이라는 값을 할당해 놓으면, 누구나 이 변수를 가져다가 쓸 수 있다.

> [!NOTE] 즉 변하지 않는 값에 final을 선언하면 매우 유용하게 사용할 수 있다.

### 참조 자료형에서의 final
```java
final MemberDTO dto = new MemberDTO();
```

위 코드로 MemberDTO의 인스턴스를 생성하면 다른 곳에서 또 생성할 수 없다.
참조 자료형도 두 번 이상 값을 할당하거나 새로 생성자를 사용하여 초기화할 수 없다.

```java
dto.name = "kyunghyun"
```
하지만 dto안에 선언되어있는 인스턴스 변수나 클래스 변수는 final이 아닌 이상 재할당이 가능하다.