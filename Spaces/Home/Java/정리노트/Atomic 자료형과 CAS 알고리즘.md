보통 동시성 문제를 해결하기 위해 자바 코드레벨에서 해결하는 방법으로 `synchronized`이나 `volatile` 키워드를 사용할 수도 있지만 각각 문제점이 존재한다.

이미 두 키워드에 대해 어느정도 안다고 가정하고, 간단하게 얘기하자면 `synchronized`은 락을 사용하기 때문에 한번에 한 스레드만 수행할 수 있어 성능상 문제가 있다.
또한 `volatile`도 `++`와 같이 원자성을 보장하지 않는 연산에서는 동시성 문제가 해결되지 않는다.

그 해결법으로 Atomic 클래스가 있는데 어떤건지 알아보자 레쓰고
  

## Atomic Class
자바에서 동시성을 보장하는 중요한 개념 중 하나가 **`Atomic(원자적)`** 자료형이다. 
`Atomic`은 논블로킹이면서 락을 사용하지 않는다. 
`Atomic`의 핵심은 이러한 소모 비용을 줄이는 `non-blocking` 방식을 사용한다는 점에서 차이점이 존재한다. 즉, 어떤 스레드도 suspended 되지 않기 때문에 context switch를 피할 수 있다.

그 이유는  내부적으로 **Compare-And-Swap(CAS) 알고리즘**을 사용하여 동시성을 보장한다.


## CAS(Compare-And-Swap) 알고리즘이란?
이들 클래스는 내부적으로 **CAS 알고리즘을 사용해 동시성을 보장**한다.
![[Pasted image 20250309022736.png]]

CAS 알고리즘은 "비교 후 교환"하는 방식으로 동작한다. 
하드웨어에서 제공하는 **원자적 연산(Atomic Operation)**을 이용하여 경쟁 상태를 피한다.

### CAS의 동작 방식
CAS 알고리즘은 다음과 같은 3가지 값을 사용한다.

- **기대 값 (Expected Value)**: 현재 예상하는 값
- **새로운 값 (New Value)**: 변경하고자 하는 값
- **메모리 주소 (Memory Address)**: 값이 저장된 주소

연산 과정은 다음과 같다.
1. 현재 값과 기대 값이 같은지 비교한다.
2. 같다면 새로운 값으로 변경한다.
3. 다르다면 변경하지 않고 아무 작업도 수행하지 않는다.

이를 자바 코드로 표현하면 다음과 같다.
```java
public boolean compareAndSwap(int expectedValue, int newValue) {
    if (memoryValue == expectedValue) { // 예상한 값이 현재 값과 같다면
        memoryValue = newValue; // 새로운 값으로 변경
        return true; // 성공
    }
    return false; // 실패
}
```


### 장점과 단점

#### 장점
- **비교적 높은 성능**: `synchronized`를 사용하지 않으므로, 블로킹 없이 동작하여 성능이 향상된다.
- **경량화된 동기화**: 락을 사용하지 않으므로 오버헤드가 줄어든다.

#### 단점
- **ABA 문제 발생 가능**: 값이 예상한 값으로 변경되었는지는 확인하지만, 변경 과정에서 다른 값으로 변했다가 다시 원래 값으로 돌아온 경우 이를 감지하지 못한다.
- **Spin Lock 발생**: CAS 연산이 반복적으로 실패할 경우 무한 루프가 발생할 수도 있다.


### ABA 문제
ABA 문제란 CAS연산에서 공유 객체에 대한 변화를 감지하지 못할 때 발생하는 현상을말한다.
CAS는 **값이 동일한지만 비교**하기 때문에, **중간에 값이 변경되었는지 여부는 알 수 없다.**  
예를 들어, 아래 상황을 가정해 보자.

1. 스레드 1이 `값 A`을 읽음 (`prev = A`).
2. 스레드 B가 `A → B → A`으로 값을 변경.
3. 스레드 A가 `compareAndSet(A, B)` 실행 → 값이 A이므로 **CAS 성공**.

이 경우, 값은 `A → B`로 정상적으로 변경되었지만,  **중간에 값이 변했다는 사실을 감지할 수 없다**. 이를 **ABA 문제**라고 한다.



